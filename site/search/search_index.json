{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Citrix Hypervisor Software Development Kit Guide Introduction Welcome to the developer's guide for Citrix Hypervisor. Here you will find the information you need in order to understand and use the Software Development Kit (SDK) that Citrix Hypervisor provides. This information will provide you with some of the architectural background and thinking that underpins the APIs, the tools that have been provided, and how to quickly get off the ground.","title":"Introduction"},{"location":"#citrix-hypervisor-software-development-kit-guide","text":"","title":"Citrix Hypervisor Software Development Kit Guide"},{"location":"#introduction","text":"Welcome to the developer's guide for Citrix Hypervisor. Here you will find the information you need in order to understand and use the Software Development Kit (SDK) that Citrix Hypervisor provides. This information will provide you with some of the architectural background and thinking that underpins the APIs, the tools that have been provided, and how to quickly get off the ground.","title":"Introduction"},{"location":"getting-started/","text":"Getting Started Citrix Hypervisor includes a Remote Procedure Call (RPC) based API providing programmatic access to the extensive set of Citrix Hypervisor management features and tools. You can call the Citrix Hypervisor Management API from a remote system or from local to the Citrix Hypervisor server. It's possible to write applications that use the Citrix Hypervisor Management API directly through raw RPC calls. However, the task of developing third-party applications is greatly simplified by using a language binding. These language bindings expose the individual API calls as first-class functions in the target language. The Citrix Hypervisor SDK provides language bindings and example code for the C, C#, Java, Python, and PowerShell programming languages. System Requirements and Preparation The first step towards using the SDK is to install Citrix Hypervisor. Citrix Hypervisor is available for download at http://www.citrix.com/downloads/citrix-hypervisor/ . For detailed instructions on how to set up your development host, see the Citrix Hypervisor Product Documentation . When the installation is complete, note the host IP address and the host password . Downloading The SDK is packaged as a ZIP file and is available as a free download from http://www.citrix.com/downloads/citrix-hypervisor/ . SDK Languages The extracted contents of the SDK ZIP file are in the CitrixHypervisor-SDK directory. The following is an overview of its structure. Where necessary, subdirectories have their own individual README files. **Note**: The examples provided aren't the same across all the SDK languages. If you intend to use one language, it's advisable to browse the sample code available in the others as well. The top level of the CitrixHypervisor-SDK directory includes the Citrix Hypervisor Management API Reference document. This document describes in more detail the API semantics and the wire protocol of the RPC messages. The API supports two wire formats, one based upon XML-RPC and one based upon JSON-RPC (v1.0 and v2.0 are both recognised). The format supported by each of the SDK languages is specified in the following sections. C The CitrixHypervisor-SDK directory contains the following folders that are relevant to C programmers: libxenserver The Citrix Hypervisor SDK for C. libxenserver/bin The libxenserver compiled binaries. libxenserver/src The libxenserver source code and examples and a Makefile to build them. Every API object is associated with a header file, which contains declarations for all that object's API functions. For example, the type definitions and functions required to invoke VM operations are all contained in xen_vm.h . C SDK dependencies The C SDK supports the XML-RPC protocol. Platform supported : Linux Windows (under cygwin) Library : The library is generated as libxenserver.so that is linked by C programs. Dependencies : XML library (libxml2.so on GNU Linux) Curl library (libcurl3.so) Examples : The following simple examples are included with the C SDK: test_vm_async_migrate : Shows how to use asynchronous API calls to migrate running VMs from a slave host to the pool master. test_vm_ops : Shows how to query the capabilities of a host, create a VM, attach a fresh blank disk image to the VM and then perform various powercycle operations. test_failures : Shows how to translate between error strings and enum_xen_api_failure. test_event_handling : Shows how to listen for events on a connection. test_enumerate : Shows how to enumerate the various API objects. test_get_records : Shows how to obtain information on API objects such as hosts, VMs, and storage repositories. C # The CitrixHypervisor-SDK directory contains the following folders that are relevant to C# programmers: XenServer.NET The Citrix Hypervisor SDK for C#.NET. XenServer.NET/bin XenServer.NET ready compiled binaries. XenServer.NET/samples XenServer.NET examples shipped as a Microsoft Visual studio solution. XenServer.NET/src XenServer.NET source code shipped as a Microsoft Visual Studio project. Every API object is associated with one C# file. For example, the functions implementing the VM operations are contained within the file VM.cs . C# SDK dependencies The C# SDK supports the JSON-RPC v2.0 protocol. The C# SDK is backwards compatible and can be used to communicate with hosts running an older version of Citrix Hypervisor or XenServer. For server versions prior to XenServer 7.3, the C# SDK uses the XML-RPC protocol, with the exception of XenServer 7.1 LTSR where the JSON-RPC v1.0 protocol is used. Platform supported : Windows with .NET version 4.5 Library : The library is generated as a Dynamic Link Library XenServer.dll that C# programs can reference. Dependencies : Newtonsoft.Json.dll is needed for the XenServer.dll to be able to communicate with the JSON-RPC backend. We ship a patched 10.0.2 version and recommend that you use this one, though others may work. CookComputing.XMLRpcV2.dll is needed for the XenServer.dll to be able to communicate with the XML-RPC backend. We ship a patched 2.5 version and recommend that you use this one, though others may work. Examples : The following examples are included with the C# SDK in the directory CitrixHypervisor-SDK/XenServer.NET/samples as separate projects of the XenSdkSample.sln solution: GetVariousRecords : logs to a Citrix Hypervisor server and displays information about hosts, storage, and virtual machines; VmPowerStates : logs to a Citrix Hypervisor server, finds a VM and takes it through the various power states. Requires a shutdown VM to be already installed. Java The CitrixHypervisor-SDK directory contains the following folders that are relevant to Java programmers: XenServerJava The Citrix Hypervisor SDK for Java XenServerJava/bin Java compiled binaries. XenServerJava/javadoc Java documentation. XenServerJava/samples Java examples. XenServerJava/src Java source code and a Makefile to build the code and the examples. Every API object is associated with one Java file. For example the functions implementing the VM operations are contained within the file VM.java . Java SDK dependencies The Java SDK supports the XML-RPC protocol. Platform supported : Linux Windows Library : The language binding is generated as a Java Archive file xenserver.jar that is linked by Java programs. Dependencies : xmlrpc-client-3.1.jar xmlrpc-common-3.1.jar ws-commons-util-1.0.2.jar These jars are needed for the xenserver.jar to be able to communicate with the xml-rpc server. These jars are shipped alongside the xenserver.jar . Examples : Running the main file CitrixHypervisor-SDK/XenServerJava/samples/RunTests.java runs a series of examples included in the same directory: AddNetwork : Adds a new internal network not attached to any NICs; SessionReuse : Shows how a Session object can be shared among multiple Connections; AsyncVMCreate : Makes asynchronously a new VM from a built-in template, starts, and stops it; VdiAndSrOps : Performs various SR and VDI tests, including creating a dummy SR; CreateVM : Creates a VM on the default SR with a network and DVD drive; DeprecatedMethod : Tests a warning is displayed when a deprecated API method is called; GetAllRecordsOfAllTypes : Retrieves all the records for all types of objects; SharedStorage : Creates a shared NFS SR; StartAllVMs : Connects to a host and tries to start each VM on it. PowerShell The CitrixHypervisor-SDK directory contains the following folders that are relevant to PowerShell users: XenServerPowerShell The Citrix Hypervisor SDK for PowerShell. XenServerPowerShell/XenServerPSModule The Citrix Hypervisor PowerShell module. XenServerPowerShell/samples PowerShell example scripts. XenServerPowerShell/src C# source code for the Citrix Hypervisor PowerShell cmdlets. Detailed installation instructions are provided within the README file accompanying the module. After the module is installed, you can obtain an overview of the cmdlets by typing: PS> Get-Help about_XenServer PowerShell SDK dependencies The PowerShell module supports the same RPC protocols as the C# SDK. Note This module is generally, but not fully, backwards compatible. To communicate with hosts running older versions of Citrix Hypervisor or XenServer, it is advisable to use the module of the same version as the host. Platform supported : Windows with .NET Framework 4.5 and PowerShell v4.0 Library : XenServerPSModule Dependencies : Newtonsoft.Json.dll is needed for the module to be able to communicate with the JSON-RPC backend. We ship a patched 10.0.2 version and recommend that you use this one, though others may work. CookComputing.XMLRpcV2.dll is needed for the module to be able to communicate with the XML-RPC backend. We ship a patched 2.5 version and recommend that you use this one, though others may work. Examples : The following example scripts are included with the PowerShell module in the directory CitrixHypervisor-SDK/XenServerPowerShell/samples : AutomatedTestCore.ps1 : Shows how to log into a Citrix Hypervisor server, create a storage repository and a VM, and then perform various powercycle operations. HttpTest.ps1 : Shows how to log into a Citrix Hypervisor server, create a VM, and then perform operations such as VM importing and exporting, patch upload, and retrieval of performance statistics. Python The CitrixHypervisor-SDK directory contains the following folders that are relevant to Python developers: XenServerPython This directory contains the Citrix Hypervisor Python module XenAPI.py . XenServerPython/samples Citrix Hypervisor Management API examples using Python. Python module dependencies The Python module supports the XML-RPC protocol. Platform supported : Linux Library : XenAPI.py Dependencies : xmlrpclib Examples : The SDK includes the following Python examples: fixpbds.py - reconfigures the settings used to access shared storage; install.py - installs a Debian VM, connects it to a network, starts it up and waits for it to report its IP address; license.py - uploads a fresh license to a Citrix Hypervisor server; permute.py - selects a set of VMs and uses live migration to move them simultaneously among hosts; powercycle.py - selects a set of VMs and powercycles them; vm_start_async.py - shows how to invoke operations asynchronously; watch-all-events.py - registers for all events and prints details when they occur. Command Line Interface (CLI) Besides using raw RPC or one of the supplied SDK languages, third-party software developers can integrate with Citrix Hypervisor servers by using the xe command line interface xe . The xe CLI is installed by default on Citrix Hypervisor servers. A stand-alone remote CLI is also available for Linux. On Windows, the xe.exe CLI executable is installed along with XenCenter. CLI dependencies Platform supported : Linux Windows Library : None Binary : xe on Linux xe.exe on Windows Dependencies : None The CLI allows almost every API call to be directly invoked from a script or other program, silently taking care of the required session management. The xe CLI syntax and capabilities are described in detail in the Citrix Hypervisor Product Documentation . For more resources and examples, visit the Citrix Knowledge Center . Note When running the CLI from a Citrix Hypervisor server console, tab completion of both command names and arguments is available.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Citrix Hypervisor includes a Remote Procedure Call (RPC) based API providing programmatic access to the extensive set of Citrix Hypervisor management features and tools. You can call the Citrix Hypervisor Management API from a remote system or from local to the Citrix Hypervisor server. It's possible to write applications that use the Citrix Hypervisor Management API directly through raw RPC calls. However, the task of developing third-party applications is greatly simplified by using a language binding. These language bindings expose the individual API calls as first-class functions in the target language. The Citrix Hypervisor SDK provides language bindings and example code for the C, C#, Java, Python, and PowerShell programming languages.","title":"Getting Started"},{"location":"getting-started/#system-requirements-and-preparation","text":"The first step towards using the SDK is to install Citrix Hypervisor. Citrix Hypervisor is available for download at http://www.citrix.com/downloads/citrix-hypervisor/ . For detailed instructions on how to set up your development host, see the Citrix Hypervisor Product Documentation . When the installation is complete, note the host IP address and the host password .","title":"System Requirements and Preparation"},{"location":"getting-started/#downloading","text":"The SDK is packaged as a ZIP file and is available as a free download from http://www.citrix.com/downloads/citrix-hypervisor/ .","title":"Downloading"},{"location":"getting-started/#sdk-languages","text":"The extracted contents of the SDK ZIP file are in the CitrixHypervisor-SDK directory. The following is an overview of its structure. Where necessary, subdirectories have their own individual README files. **Note**: The examples provided aren't the same across all the SDK languages. If you intend to use one language, it's advisable to browse the sample code available in the others as well. The top level of the CitrixHypervisor-SDK directory includes the Citrix Hypervisor Management API Reference document. This document describes in more detail the API semantics and the wire protocol of the RPC messages. The API supports two wire formats, one based upon XML-RPC and one based upon JSON-RPC (v1.0 and v2.0 are both recognised). The format supported by each of the SDK languages is specified in the following sections.","title":"SDK Languages"},{"location":"getting-started/#c","text":"The CitrixHypervisor-SDK directory contains the following folders that are relevant to C programmers: libxenserver The Citrix Hypervisor SDK for C. libxenserver/bin The libxenserver compiled binaries. libxenserver/src The libxenserver source code and examples and a Makefile to build them. Every API object is associated with a header file, which contains declarations for all that object's API functions. For example, the type definitions and functions required to invoke VM operations are all contained in xen_vm.h .","title":"C"},{"location":"getting-started/#c-sdk-dependencies","text":"The C SDK supports the XML-RPC protocol. Platform supported : Linux Windows (under cygwin) Library : The library is generated as libxenserver.so that is linked by C programs. Dependencies : XML library (libxml2.so on GNU Linux) Curl library (libcurl3.so) Examples : The following simple examples are included with the C SDK: test_vm_async_migrate : Shows how to use asynchronous API calls to migrate running VMs from a slave host to the pool master. test_vm_ops : Shows how to query the capabilities of a host, create a VM, attach a fresh blank disk image to the VM and then perform various powercycle operations. test_failures : Shows how to translate between error strings and enum_xen_api_failure. test_event_handling : Shows how to listen for events on a connection. test_enumerate : Shows how to enumerate the various API objects. test_get_records : Shows how to obtain information on API objects such as hosts, VMs, and storage repositories.","title":"C SDK dependencies"},{"location":"getting-started/#c_1","text":"The CitrixHypervisor-SDK directory contains the following folders that are relevant to C# programmers: XenServer.NET The Citrix Hypervisor SDK for C#.NET. XenServer.NET/bin XenServer.NET ready compiled binaries. XenServer.NET/samples XenServer.NET examples shipped as a Microsoft Visual studio solution. XenServer.NET/src XenServer.NET source code shipped as a Microsoft Visual Studio project. Every API object is associated with one C# file. For example, the functions implementing the VM operations are contained within the file VM.cs .","title":"C &#35;"},{"location":"getting-started/#c-sdk-dependencies_1","text":"The C# SDK supports the JSON-RPC v2.0 protocol. The C# SDK is backwards compatible and can be used to communicate with hosts running an older version of Citrix Hypervisor or XenServer. For server versions prior to XenServer 7.3, the C# SDK uses the XML-RPC protocol, with the exception of XenServer 7.1 LTSR where the JSON-RPC v1.0 protocol is used. Platform supported : Windows with .NET version 4.5 Library : The library is generated as a Dynamic Link Library XenServer.dll that C# programs can reference. Dependencies : Newtonsoft.Json.dll is needed for the XenServer.dll to be able to communicate with the JSON-RPC backend. We ship a patched 10.0.2 version and recommend that you use this one, though others may work. CookComputing.XMLRpcV2.dll is needed for the XenServer.dll to be able to communicate with the XML-RPC backend. We ship a patched 2.5 version and recommend that you use this one, though others may work. Examples : The following examples are included with the C# SDK in the directory CitrixHypervisor-SDK/XenServer.NET/samples as separate projects of the XenSdkSample.sln solution: GetVariousRecords : logs to a Citrix Hypervisor server and displays information about hosts, storage, and virtual machines; VmPowerStates : logs to a Citrix Hypervisor server, finds a VM and takes it through the various power states. Requires a shutdown VM to be already installed.","title":"C# SDK dependencies"},{"location":"getting-started/#java","text":"The CitrixHypervisor-SDK directory contains the following folders that are relevant to Java programmers: XenServerJava The Citrix Hypervisor SDK for Java XenServerJava/bin Java compiled binaries. XenServerJava/javadoc Java documentation. XenServerJava/samples Java examples. XenServerJava/src Java source code and a Makefile to build the code and the examples. Every API object is associated with one Java file. For example the functions implementing the VM operations are contained within the file VM.java .","title":"Java"},{"location":"getting-started/#java-sdk-dependencies","text":"The Java SDK supports the XML-RPC protocol. Platform supported : Linux Windows Library : The language binding is generated as a Java Archive file xenserver.jar that is linked by Java programs. Dependencies : xmlrpc-client-3.1.jar xmlrpc-common-3.1.jar ws-commons-util-1.0.2.jar These jars are needed for the xenserver.jar to be able to communicate with the xml-rpc server. These jars are shipped alongside the xenserver.jar . Examples : Running the main file CitrixHypervisor-SDK/XenServerJava/samples/RunTests.java runs a series of examples included in the same directory: AddNetwork : Adds a new internal network not attached to any NICs; SessionReuse : Shows how a Session object can be shared among multiple Connections; AsyncVMCreate : Makes asynchronously a new VM from a built-in template, starts, and stops it; VdiAndSrOps : Performs various SR and VDI tests, including creating a dummy SR; CreateVM : Creates a VM on the default SR with a network and DVD drive; DeprecatedMethod : Tests a warning is displayed when a deprecated API method is called; GetAllRecordsOfAllTypes : Retrieves all the records for all types of objects; SharedStorage : Creates a shared NFS SR; StartAllVMs : Connects to a host and tries to start each VM on it.","title":"Java SDK dependencies"},{"location":"getting-started/#powershell","text":"The CitrixHypervisor-SDK directory contains the following folders that are relevant to PowerShell users: XenServerPowerShell The Citrix Hypervisor SDK for PowerShell. XenServerPowerShell/XenServerPSModule The Citrix Hypervisor PowerShell module. XenServerPowerShell/samples PowerShell example scripts. XenServerPowerShell/src C# source code for the Citrix Hypervisor PowerShell cmdlets. Detailed installation instructions are provided within the README file accompanying the module. After the module is installed, you can obtain an overview of the cmdlets by typing: PS> Get-Help about_XenServer","title":"PowerShell"},{"location":"getting-started/#powershell-sdk-dependencies","text":"The PowerShell module supports the same RPC protocols as the C# SDK. Note This module is generally, but not fully, backwards compatible. To communicate with hosts running older versions of Citrix Hypervisor or XenServer, it is advisable to use the module of the same version as the host. Platform supported : Windows with .NET Framework 4.5 and PowerShell v4.0 Library : XenServerPSModule Dependencies : Newtonsoft.Json.dll is needed for the module to be able to communicate with the JSON-RPC backend. We ship a patched 10.0.2 version and recommend that you use this one, though others may work. CookComputing.XMLRpcV2.dll is needed for the module to be able to communicate with the XML-RPC backend. We ship a patched 2.5 version and recommend that you use this one, though others may work. Examples : The following example scripts are included with the PowerShell module in the directory CitrixHypervisor-SDK/XenServerPowerShell/samples : AutomatedTestCore.ps1 : Shows how to log into a Citrix Hypervisor server, create a storage repository and a VM, and then perform various powercycle operations. HttpTest.ps1 : Shows how to log into a Citrix Hypervisor server, create a VM, and then perform operations such as VM importing and exporting, patch upload, and retrieval of performance statistics.","title":"PowerShell SDK dependencies"},{"location":"getting-started/#python","text":"The CitrixHypervisor-SDK directory contains the following folders that are relevant to Python developers: XenServerPython This directory contains the Citrix Hypervisor Python module XenAPI.py . XenServerPython/samples Citrix Hypervisor Management API examples using Python.","title":"Python"},{"location":"getting-started/#python-module-dependencies","text":"The Python module supports the XML-RPC protocol. Platform supported : Linux Library : XenAPI.py Dependencies : xmlrpclib Examples : The SDK includes the following Python examples: fixpbds.py - reconfigures the settings used to access shared storage; install.py - installs a Debian VM, connects it to a network, starts it up and waits for it to report its IP address; license.py - uploads a fresh license to a Citrix Hypervisor server; permute.py - selects a set of VMs and uses live migration to move them simultaneously among hosts; powercycle.py - selects a set of VMs and powercycles them; vm_start_async.py - shows how to invoke operations asynchronously; watch-all-events.py - registers for all events and prints details when they occur.","title":"Python module dependencies"},{"location":"getting-started/#command-line-interface-cli","text":"Besides using raw RPC or one of the supplied SDK languages, third-party software developers can integrate with Citrix Hypervisor servers by using the xe command line interface xe . The xe CLI is installed by default on Citrix Hypervisor servers. A stand-alone remote CLI is also available for Linux. On Windows, the xe.exe CLI executable is installed along with XenCenter.","title":"Command Line Interface (CLI)"},{"location":"getting-started/#cli-dependencies","text":"Platform supported : Linux Windows Library : None Binary : xe on Linux xe.exe on Windows Dependencies : None The CLI allows almost every API call to be directly invoked from a script or other program, silently taking care of the required session management. The xe CLI syntax and capabilities are described in detail in the Citrix Hypervisor Product Documentation . For more resources and examples, visit the Citrix Knowledge Center . Note When running the CLI from a Citrix Hypervisor server console, tab completion of both command names and arguments is available.","title":"CLI dependencies"},{"location":"overview/","text":"Overview of the Citrix Hypervisor Management API This chapter introduces the Citrix Hypervisor Management API (after here referred to as the \"API\") and its associated object model. The API has the following key features: Management of all aspects of the Citrix Hypervisor server. The API allows you to manage VMs, storage, networking, host configuration, and pools. Performance and status metrics can also be queried from the API. Persistent Object Model. The results of all side-effecting operations (for example: object creation, deletion, and parameter changes) are persisted in a server-side database that is managed by Citrix Hypervisor. An event mechanism. Through the API, clients can register to be notified when persistent (server-side) objects are changed. This enables applications to track datamodel changes performed by concurrently executing clients. Synchronous and asynchronous invocation. All API calls can be invoked synchronously (that is, block until completion). Any API call that might be long-running can also be invoked asynchronously . Asynchronous calls return immediately with a reference to a task object. This task object can be queried (through the API) for progress and status information. When an asynchronously invoked operation completes, the result (or error code) is available from the task object. Remotable and Cross-Platform. The client issuing the API calls doesn't have to be resident on the host being managed. The client also does not have to be connected to the host over ssh to execute the API. API calls use the RPC protocol to transmit requests and responses over the network. Secure and Authenticated Access. The RPC API backend executing on the host accepts secure socket connections. This allows a client to execute the APIs over the https protocol. Further, all the API calls execute in the context of a login session generated through user name and password validation at the server. This provides secure and authenticated access to the Citrix Hypervisor installation. Citrix Hypervisor Management API Deprecation Policy Items that will be removed in a future release are marked as deprecated. By default, Citrix continues to support deprecated APIs and product functionality up to and including the next Citrix Hypervisor Long Term Service Release (LTSR). Deprecated items are usually removed in a Current Release following that LTSR. In exceptional cases, an item might be deprecated and removed before the next LTSR. For example, a change might be required to improve security. If this happens, Citrix makes customers aware of the change to the API or the product functionality. This deprecation policy applies only to APIs and functionality that are documented at the following locations: Citrix Product Documentation Citrix Developer Documentation Getting Started with the API Let's start our tour of the API by describing the calls required to create a VM on a Citrix Hypervisor installation, and take it through a start/suspend/resume/stop cycle. This section does not reference code in any specific language. At this stage we just describe the informal sequence of RPC invocations that do our \"install and start\" task. Note We recommend strongly against using the VM.create call, which might be removed or changed in a future version of the API. Read on to learn other ways to make a new VM. Authentication: acquiring a session reference The first step is to call Session.login_with_password(username, password, client_API_version, originator) . The API is session based, so before you can make other calls you must authenticate with the server. Assuming the user name and password are authenticated correctly, the result of this call is a session reference . Subsequent API calls take the session reference as a parameter. In this way, we ensure that only API users who are suitably authorized can perform operations on a Citrix Hypervisor installation. You can continue to use the same session for any number of API calls. When you have finished the session, recommends that you call Session.logout(session) to clean up: see later. Acquiring a list of templates to base a new VM installation on The next step is to query the list of \"templates\" on the host. Templates are specially marked VM objects that specify suitable default parameters for various supported guest types. (If you want to see a quick enumeration of the templates on a Citrix Hypervisor installation for yourself, you can execute the xe template-list CLI command.) To get a list of templates from the API, find the VM objects on the server that have their is_a_template field set to true. One way to do find these objects is by calling VM.get_all_records(session) where the session parameter is the reference we acquired from our Session.login_with_password call earlier. This call queries the server, returning a snapshot (taken at the time of the call) containing all the VM object references and their field values. (Remember that at this stage we are not concerned with how the returned object references and field values can be manipulated in any particular client language: that detail is dealt with by each language-specific SDK and described concretely in the following chapter. For now, assume the existence of an abstract mechanism for reading and manipulating objects and field values returned by API calls.) Now we have a snapshot of the VM objects' field values in the memory of our client application, iterate through them and find the VMs that have their is_a_template value set to true . At this stage, let's assume that our example application further iterates through the template objects and remembers the reference corresponding to the one that has its \" name_label \" set to \"Debian Etch 4.0\" (one of the default Linux templates supplied with Citrix Hypervisor). Installing the VM based on a template Continuing through our example, we must now install a new VM based on the template we selected. The installation process requires two API calls: First we must now invoke the API call VM.clone(session, t_ref, \"my first VM\") . This call tells the server to clone the VM object referenced by t_ref to make a new VM object. The return value of this call is the VM reference corresponding to the newly created VM. Let's call this new_vm_ref . At this stage, the object referred to by new_vm_ref is still a template (like the VM object referred to by t_ref , from which it was cloned). To make new_vm_ref into a VM object, we must call VM.provision(session, new_vm_ref) . When this call returns the new_vm_ref object will have had its is_a_template field set to false, indicating that new_vm_ref now refers to a regular VM ready for starting. Note The provision operation can take a few minutes, as it is as during this call that the template's disk images are created. For the Debian template, the newly created disks are also at this stage populated with a Debian root filesystem. Taking the VM through a start/suspend/resume/stop cycle Now we have an object reference representing our newly installed VM, it is trivial to take it through a few lifecycle operations: To start our VM, we can call VM.start(session, new_vm_ref) After it's running, we can suspend it by calling VM.suspend(session, new_vm_ref) , We can resume it by calling VM.resume(session, new_vm_ref) . We can call VM.shutdown(session, new_vm_ref) to shut down the VM cleanly. Logging out When an application is finished interacting with a Citrix Hypervisor server, it is good practice to call Session.logout(session) . This call invalidates the session reference (so it cannot be used in subsequent API calls) and deallocates server-side memory used to store the session object. Although inactive sessions eventually time out, the server has a hardcoded limit of 500 concurrent sessions for each username or originator . After this limit has been reached, fresh logins evict the session objects that have been used least recently. The session references of these evicted session objects become invalid. For successful interoperability with other applications, concurrently accessing the server, the best policy is: Choose a string that identifies your application and its version. Create a single session at start-of-day, using that identifying string for the originator parameter to Session.login_with_password . Use this session throughout the application and then explicitly logout when possible. Note: Sessions can be used across multiple separate client-server network connections . If a poorly written client leaks sessions or otherwise exceeds the limit, then as long as the client uses an appropriate originator argument, it is easily identifiable from the Citrix Hypervisor logs. Citrix Hypervisor destroys the longest-idle sessions of the rogue client only. This behavior might cause problems for that client but not for other clients. If the misbehaving client doesn't specify an originator , it is harder to identify and causes the premature destruction of other client sessions that also didn't specify an originator Install and start example: summary We have seen how the API can be used to install a VM from a Citrix Hypervisor template and perform various lifecycle operations on it. Note that the number of calls we had to make to affect these operations was small: One call to acquire a session: Session.login_with_password() One call to query the VM (and template) objects present on the Citrix Hypervisor installation: VM.get_all_records() . Recall that we used the information returned from this call to select a suitable template to install from. Two calls to install a VM from our chosen template: VM.clone() , followed by VM.provision() . One call to start the resultant VM: VM.start() (and similarly other single calls to suspend, resume, and shut down accordingly) And then one call to log out Session.logout() Although the API as a whole is complex and fully featured, common tasks (such as VM lifecycle operations) are straightforward, requiring only a few simple API calls. Keep this fact in mind as you study the next section which might, on first reading, appear a little daunting! Object Model Overview This section gives a high-level overview of the object model of the API. For a more detailed description of the parameters and methods of each class, see the Citrix Hypervisor Management API reference. We start by giving a brief outline of some of the core classes that make up the API. (Don't worry if these definitions seem abstract in their initial presentation. The textual description in the following sections, and the code-sample walk through in the next section make these concepts concrete.) VM A VM object represents a particular virtual machine instance on a Citrix Hypervisor server or Resource Pool. Example methods include start , suspend , pool_migrate ; example parameters include power_state , memory_static_max , and name_label . (In the previous section we saw how the VM class is used to represent both templates and regular VMs) Host A host object represents a physical host in a Citrix Hypervisor pool. Example methods include reboot and shutdown . Example parameters include software_version , hostname , and [IP] address . VDI A VDI object represents a Virtual Disk Image . Virtual Disk Images can be attached to VMs. A block device appears inside the VM through which the bits encapsulated by the attached Virtual Disk Image can be read and written. Example methods of the VDI class include resize and clone . Example fields include virtual_size and sharable . When we called VM.provision on the VM template in our previous example, some VDI objects were automatically created to represent the newly created disks. These VDIs were attached to the VM object. SR An SR ( Storage Repository ) aggregates a collection of VDIs, It encapsulates the properties of physical storage on which the VDIs' bits reside. Example parameters include: type which determines the storage-specific driver a Citrix Hypervisor installation uses to read/write the SR's VDIs physical_utilisation Example methods include scan which invokes the storage-specific driver to acquire a list of the VDIs contained with the SR and the properties of these VDIs create which initializes a block of physical storage so it is ready to store VDIs Network A network object represents a layer-2 network that exists in the environment in which the Citrix Hypervisor server instance lives. Since Citrix Hypervisor does not manage networks directly, network is a lightweight class that models physical and virtual network topology. VM and Host objects that are attached to a particular Network object can send network packets to each other. The objects are attached through VIF and PIF instances. For more information, see the following section. If you are finding this enumeration of classes rather terse, you can skip to the code walk-throughs of the next chapter. There are plenty of useful applications that can be written using only a subset of the classes already described. If you want to continue this description of classes in the abstract, read on. In addition to the classes listed in the previous section, there are four more that act as connectors . These connectors specify relationships between VMs and Hosts and Storage and Networks. The first two of these classes that we consider, VBD and VIF , determine how VMs are attached to virtual disks and network objects respectively. VBD A VBD ( Virtual Block Device ) object represents an attachment between a VM and a VDI. When a VM is booted, its VBD objects are queried to determine which disk images (VDIs) to attach. Example methods of the VBD class include: plug which hot plugs a disk device into a running VM, making the specified VDI accessible therein unplug which hot unplugs a disk device from a running guest Example fields include: device which determines the device name inside the guest under which the specified VDI is made accessible VIF A VIF ( Virtual Network Interface ) object represents an attachment between a VM and a Network object. When a VM is booted, its VIF objects are queried to determine which network devices to create. Example methods of the VIF class include: plug which hot plugs a network device into a running VM unplug which hot unplugs a network device from a running guest The second set of \"connector classes\" that we consider determine how Hosts are attached to Networks and Storage. PIF A PIF ( Physical Interface ) object represents an attachment between a Host and a Network object. If a host is connected to a Network over a PIF, packets from the specified host can be transmitted/received by the corresponding host. Example fields of the PIF class include: device which specifies the device name to which the PIF corresponds. For example, eth0 MAC which specifies the MAC address of the underlying NIC that a PIF represents PIFs abstract both physical interfaces and VLANs (the latter distinguished by the existence of a positive integer in the \"VLAN\" field). PBD A PBD ( Physical Block Device ) object represents an attachment between a Host and an SR (Storage Repository) object. Fields include: currently-attached which specifies whether the chunk of storage represented by the specified SR object is available to the host device_config which specifies storage-driver specific parameters that determine how the low-level storage devices are configured on the specified host. For example, when an SR rendered on an NFS filer, device_config can specify the host-name of the filer and the path on the filer in which the SR files live. This figure presents a graphical overview of the API classes involved in managing VMs, Hosts, Storage, and Networking. From this diagram, the symmetry between storage and network configuration, and also the symmetry between virtual machine and host configuration is plain to see. Working with VIFs and VBDs In this section we walk through a few more complex scenarios. These scenarios describe how various tasks involving virtual storage and network devices can be done using the API. Creating disks and attaching them to VMs Let's start by considering how to make a new blank disk image and attach it to a running VM. We assume that we already have a running VM, and we know its corresponding API object reference. For example, we might have created this VM using the procedure described in the previous section and had the server return its reference to us. We also assume that we have authenticated with the Citrix Hypervisor installation and have a corresponding session reference . Indeed in the rest of this chapter, for the sake of brevity, does not mention sessions altogether. Creating a new blank disk image First, instantiate the disk image on physical storage by calling VDI.create() . The VDI.create call takes a number of parameters, including: name_label and name_description : a human-readable name/description for the disk (for example, for convenient display in the UI). These fields can be left blank if desired. SR : the object reference of the Storage Repository representing the physical storage in which the VDI's bits are placed. read_only : setting this field to true indicates that the VDI can only be attached to VMs in a read-only fashion. (Attempting to attach a VDI with its read_only field set to true in a read/write fashion results in error.) Invoking the VDI.create call causes the Citrix Hypervisor installation to create a blank disk image on physical storage, create an associated VDI object (the datamodel instance that refers to the disk image on physical storage) and return a reference to this newly created VDI object. The way in which the disk image is represented on physical storage depends on the type of the SR in which the created VDI resides. For example, if the SR is of type \"lvm\" then the new disk image will be rendered as an LVM volume; if the SR is of type \"nfs\" then the new disk image will be a sparse VHD file created on an NFS filer. (You can query the SR type through the API using the SR.get_type() call.) Note Some SR types might round up the virtual-size value to make it divisible by a configured block size. Attaching the disk image to a VM So far we have a running VM (that we assumed the existence of at the start of this example) and a fresh VDI that we just created. Right now, these are both independent objects that exist on the Citrix Hypervisor Host, but there is nothing linking them together. So our next step is to create such a link, associating the VDI with our VM. The attachment is formed by creating a new \"connector\" object called a VBD ( Virtual Block Device ). To create our VBD we invoke the VBD.create() call. The VBD.create() call takes a number of parameters including: VM - the object reference of the VM to which the VDI is to be attached VDI - the object reference of the VDI that is to be attached mode - specifies whether the VDI is to be attached in a read-only or a read-write fashion userdevice - specifies the block device inside the guest through which applications running inside the VM will be able to read/write the VDI's bits. type - specifies whether the VDI should be presented inside the VM as a regular disk or as a CD. (Note that this particular field has more meaning for Windows VMs than it does for Linux VMs, but we will not explore this level of detail in this chapter.) Invoking VBD.create makes a VBD object on the Citrix Hypervisor installation and returns its object reference. However, this call in itself does not have any side-effects on the running VM (that is, if you go and look inside the running VM you will see that the block device has not been created). The fact that the VBD object exists but that the block device in the guest is not active, is reflected by the fact that the VBD object's currently_attached field is set to false. For expository purposes, this figure presents a graphical example that shows the relationship between VMs, VBDs, VDIs and SRs. In this instance a VM object has 2 attached VDIs: there are two VBD objects that form the connections between the VM object and its VDIs; and the VDIs reside within the same SR. Hotplugging the VBD If we rebooted the VM at this stage then, after rebooting, the block device corresponding to the VBD would appear: on boot, Citrix Hypervisor queries all VBDs of a VM and actively attaches each of the corresponding VDIs. Rebooting the VM is all very well, but recall that we wanted to attach a newly created blank disk to a running VM. This can be achieved by invoking the plug method on the newly created VBD object. When the plug call returns successfully, the block device to which the VBD relates will have appeared inside the running VM -- i.e. from the perspective of the running VM, the guest operating system is led to believe that a new disk device has just been hot plugged . Mirroring this fact in the managed world of the API, the currently_attached field of the VBD is set to true. Unsurprisingly, the VBD plug method has a dual called \" unplug \". Invoking the unplug method on a VBD object causes the associated block device to be hot unplugged from a running VM, setting the currently_attached field of the VBD object to false accordingly. Creating and attaching Network Devices to VMs The API calls involved in configuring virtual network interfaces in VMs are similar in many respects to the calls involved in configuring virtual disk devices. For this reason we will not run through a full example of how one can create network interfaces using the API object-model; instead we will use this section just to outline briefly the symmetry between virtual networking device and virtual storage device configuration. The networking analogue of the VBD class is the VIF class. Just as a VBD is the API representation of a block device inside a VM, a VIF ( Virtual network InterFace ) is the API representation of a network device inside a VM. Whereas VBDs associate VM objects with VDI objects, VIFs associate VM objects with Network objects. Just like VBDs, VIFs have a currently_attached field that determines whether or not the network device (inside the guest) associated with the VIF is currently active or not. And as we saw with VBDs, at VM boot-time the VIFs of the VM are queried and a corresponding network device for each created inside the booting VM. Similarly, VIFs also have plug and unplug methods for hot plugging/unplugging network devices in/out of running VMs. Host configuration for networking and storage We have seen that the VBD and VIF classes are used to manage configuration of block devices and network devices (respectively) inside VMs. To manage host configuration of storage and networking there are two analogous classes: PBD ( Physical Block Device ) and PIF ( Physical [network] InterFace ). Host storage configuration: PBDs Let us start by considering the PBD class. A PBD_create() call takes a number of parameters including: Parameter Description host physical machine on which the PBD is available SR the Storage Repository that the PBD connects to device_config a string-to-string map that is provided to the host's SR-backend-driver, containing the low-level parameters required to configure the physical storage device(s) on which the SR is to be realized. The specific contents of the device_config field depend on the type of the SR to which the PBD is connected. (Executing xe sm-list will show a list of possible SR types; the configuration field in this enumeration specifies the device_config parameters that each SR type expects.) For example, imagine we have an SR object s of type \"nfs\" (representing a directory on an NFS filer within which VDIs are stored as VHD files); and let's say that we want a host, h , to be able to access s . In this case we invoke PBD.create() specifying host h , SR s , and a value for the device_config parameter that is the following map: (\"server\", \"my_nfs_server.example.com\"), (\"serverpath\", \"/scratch/mysrs/sr1\") This tells the Citrix Hypervisor server that SR s is accessible on host h , and further that to access SR s , the host needs to mount the directory /scratch/mysrs/sr1 on the NFS server named my_nfs_server.example.com . Like VBD objects, PBD objects also have a field called currently_attached . Storage repositories can be attached and detached from a given host by invoking PBD.plug and PBD.unplug methods respectively. Host networking configuration: PIFs Host network configuration is specified by virtue of PIF objects. If a PIF object connects a network object, n , to a host object h , then the network corresponding to n is bridged onto a physical interface (or a physical interface plus a VLAN tag) specified by the fields of the PIF object. For example, imagine a PIF object exists connecting host h to a network n , and that device field of the PIF object is set to eth0 . This means that all packets on network n are bridged to the NIC in the host corresponding to host network device eth0 . Exporting and Importing VMs VMs can be exported to a file and later imported to any Citrix Hypervisor server. The export protocol is a simple HTTP(S) GET, which should be performed on the master if the VM is on a pool member. Authorization is either standard HTTP basic authentication, or if a session has already been obtained, this can be used. The VM to export is specified either by UUID or by reference. To keep track of the export, a task can be created and passed in using its reference. The request might result in a redirect if the VM's disks are only accessible on a pool member. The following arguments are passed on the command line: Argument Description session_id the reference of the session being used to authenticate; required only when not using HTTP basic authentication task_id the reference of the task object with which to keep track of the operation; optional, required only if you have created a task object to keep track of the export ref the reference of the VM; required only if not using the UUID uuid the UUID of the VM; required only if not using the reference For example, using the Linux command line tool cURL: curl http://root:foo@myhypervisor1/export?uuid=<vm_uuid> -o <exportfile> This command will export the specified VM to the file exportfile . To export just the metadata, use the URI http://server/export_metadata . The import protocol is similar, using HTTP(S) PUT. The session_id and task_id arguments are as for the export. The ref and uuid are not used; a new reference and uuid will be generated for the VM. There are some additional parameters: Argument Description restore if true , the import is treated as replacing the original VM - the implication of this currently is that the MAC addresses on the VIFs are exactly as the export was, which will lead to conflicts if the original VM is still being run. force if true , any checksum failures will be ignored (the default is to destroy the VM if a checksum error is detected) sr_id the reference of an SR into which the VM should be imported. The default behavior is to import into the Pool.default_SR . For example, again using cURL: curl -T <exportfile> http://root:foo@myhypervisor2/import This command will import the VM to the default SR on the server. Note Note that if no default SR has been set, and no sr_uuid is specified, the error message \"DEFAULT_SR_NOT_FOUND\" is returned. Another example: curl -T <exportfile> http://root:foo@myhypervisor2/import?sr_id=<opaque_ref_of_sr> This command will import the VM to the specified SR on the server. To import just the metadata, use the URI http://server/import_metadata Xen Virtual Appliance (XVA) VM Import Format Citrix Hypervisor supports a human-readable legacy VM input format called XVA. This section describes the syntax and structure of XVA. An XVA consists of a directory containing XML metadata and a set of disk images. A VM represented by an XVA is not intended to be directly executable. Data within an XVA package is compressed and intended for either archiving on permanent storage or for being transmitted to a VM server - such as a Citrix Hypervisor server - where it can be decompressed and executed. XVA is a hypervisor-neutral packaging format; it should be possible to create simple tools to instantiate an XVA VM on any other platform. XVA does not specify any particular runtime format; for example disks may be instantiated as file images, LVM volumes, QCoW images, VMDK or VHD images. An XVA VM may be instantiated any number of times, each instantiation may have a different runtime format. XVA does not: specify any particular serialization or transport format provide any mechanism for customizing VMs (or templates) on install address how a VM may be upgraded post-install define how multiple VMs, acting as an appliance, may communicate These issues are all addressed by the related Open Virtual Appliance specification. An XVA is a directory containing, at a minimum, a file called ova.xml . This file describes the VM contained within the XVA and is described in Section 3.2. Disks are stored within sub-directories and are referenced from the ova.xml. The format of disk data is described in a later section. The following terms are used in the rest of this article: HVM: a mode in which unmodified OS kernels run with the help of virtualization support in the hardware. PV: a mode in which specially modified \"paravirtualized\" kernels run explicitly on top of a hypervisor without requiring hardware support for virtualization. The \"ova.xml\" file contains the following elements: <appliance version=\"0.1\"> The number in the attribute \"version\" indicates the version of this specification to which the XVA is constructed; in this case version 0.1. Inside the <appliance> there is exactly one <vm>: (in the OVA specification, multiple <vm>s are permitted) <vm name=\"name\"> Each <vm> element describes one VM. The \"name\" attribute is for future internal use only and must be unique within the ova.xml file. The \"name\" attribute is permitted to be any valid UTF-8 string. Inside each <vm> tag are the following compulsory elements: <label>... text ... </label> A short name for the VM to be displayed in a UI. <shortdesc> ... description ... </shortdesc> A description for the VM to be displayed in the UI. Note that for both <label> and <shortdesc> contents, leading and trailing whitespace will be ignored. <config mem_set=\"268435456\" vcpus=\"1\"/> The <config> element has attributes which describe the amount of memory in bytes (mem_set) and number of CPUs (VCPUs) the VM should have. Each <vm> has zero or more <vbd> elements representing block devices which look like the following: <vbd device=\"sda\" function=\"root\" mode=\"w\" vdi=\"vdi_sda\"/> The attributes have the following meanings: device name of the physical device to expose to the VM. For linux guests we use \"sd[a-z]\" and for windows guests we use \"hd[a-d]\". function if marked as \"root\", this disk will be used to boot the guest. (NB this does not imply the existence of the Linux root i.e. / filesystem) Only one device should be marked as \"root\". See Section 3.4 describing VM booting. Any other string is ignored. mode either \"w\" or \"ro\" if the device is to be read/write or read-only vdi the name of the disk image (represented by a <vdi> element) to which this block device is connected Each <vm> may have an optional <hacks> section like the following: <hacks is_hvm=\"false\" kernel_boot_cmdline=\"root=/dev/sda1 ro\"/> The <hacks> element is present in the XVA files generated by Citrix Hypervisor but will be removed in future. The attribute \"is_hvm\" is either \"true\" or \"false\", depending on whether the VM should be booted in HVM or not. The \"kernel_boot_cmdline\" contains additional kernel commandline arguments when booting a guest using pygrub. In addition to a <vm> element, the <appliance> will contain zero or more <vdi> elements like the following: <vdi name=\"vdi_sda\" size=\"5368709120\" source=\"file://sda\" type=\"dir-gzipped-chunks\"> Each <vdi> corresponds to a disk image. The attributes have the following meanings: name: name of the VDI, referenced by the vdi attribute of <vbd> elements. Any valid UTF-8 string is permitted. size: size of the required image in bytes source: a URI describing where to find the data for the image, only file:// URIs are currently permitted and must describe paths relative to the directory containing the ova.xml type: describes the format of the disk data A single disk image encoding is specified in which has type \"dir-gzipped-chunks\": Each image is represented by a directory containing a sequence of files as follows: -rw-r--r-- 1 dscott xendev 458286013 Sep 18 09:51 chunk000000000.gz -rw-r--r-- 1 dscott xendev 422271283 Sep 18 09:52 chunk000000001.gz -rw-r--r-- 1 dscott xendev 395914244 Sep 18 09:53 chunk000000002.gz -rw-r--r-- 1 dscott xendev 9452401 Sep 18 09:53 chunk000000003.gz -rw-r--r-- 1 dscott xendev 1096066 Sep 18 09:53 chunk000000004.gz -rw-r--r-- 1 dscott xendev 971976 Sep 18 09:53 chunk000000005.gz -rw-r--r-- 1 dscott xendev 971976 Sep 18 09:53 chunk000000006.gz -rw-r--r-- 1 dscott xendev 971976 Sep 18 09:53 chunk000000007.gz -rw-r--r-- 1 dscott xendev 573930 Sep 18 09:53 chunk000000008.gz Each file (named \"chunk-XXXXXXXXX.gz\") is a gzipped file containing exactly 1e9 bytes (1GB, not 1GiB) of raw block data. The small size was chosen to be safely under the maximum file size limits of several filesystems. If the files are gunzipped and then concatenated together, the original image is recovered. Citrix Hypervisor provides two mechanisms for booting a VM: (i) using a paravirtualized kernel extracted through pygrub; and (ii) using HVM. The current implementation uses the \"is_hvm\" flag within the <hacks> section to decide which mechanism to use. This rest of this section describes a very simple Debian VM packaged as an XVA. The VM has two disks, one with size 5120MiB and used for the root filesystem and used to boot the guest using pygrub and the other of size 512MiB which is used for swap. The VM has 512MiB of memory and uses one virtual CPU. At the topmost level the simple Debian VM is represented by a single directory: $ ls -l total 4 drwxr-xr-x 3 dscott xendev 4096 Oct 24 09:42 very simple Debian VM Inside the main XVA directory are two sub-directories - one per disk - and the single file: ova.xml: $ ls -l very\\ simple\\ Debian\\ VM/ total 8 -rw-r--r-- 1 dscott xendev 1016 Oct 24 09:42 ova.xml drwxr-xr-x 2 dscott xendev 4096 Oct 24 09:42 sda drwxr-xr-x 2 dscott xendev 4096 Oct 24 09:53 sdb Inside each disk sub-directory are a set of files, each file contains 1GB of raw disk block data compressed using gzip: $ ls -l very\\ simple\\ Debian\\ VM/sda/ total 2053480 -rw-r--r-- 1 dscott xendev 202121645 Oct 24 09:43 chunk-000000000.gz -rw-r--r-- 1 dscott xendev 332739042 Oct 24 09:45 chunk-000000001.gz -rw-r--r-- 1 dscott xendev 401299288 Oct 24 09:48 chunk-000000002.gz -rw-r--r-- 1 dscott xendev 389585534 Oct 24 09:50 chunk-000000003.gz -rw-r--r-- 1 dscott xendev 624567877 Oct 24 09:53 chunk-000000004.gz -rw-r--r-- 1 dscott xendev 150351797 Oct 24 09:54 chunk-000000005.gz $ ls -l very\\ simple\\ Debian\\ VM/sdb total 516 -rw-r--r-- 1 dscott xendev 521937 Oct 24 09:54 chunk-000000000.gz The example simple Debian VM would have an XVA file like the following: <?xml version=\"1.0\" ?> <appliance version=\"0.1\"> <vm name=\"vm\"> <label>very simple Debian VM</label> <shortdesc>the description field can contain any valid UTF-8</shortdesc> <config mem_set=\"536870912\" vcpus=\"1\"/> <hacks is_hvm=\"false\" kernel_boot_cmdline=\"root=/dev/sda1 ro \"> <!--This section is temporary and will be ignored in future. Attribute is_hvm (\"true\" or \"false\") indicates whether the VM will be booted in HVM mode. In future this will be autodetected. Attribute kernel_boot_cmdline contains the kernel commandline for the case where a proper grub menu.lst is not present. In future booting shall only use pygrub.--> </hacks> <vbd device=\"sda\" function=\"root\" mode=\"w\" vdi=\"vdi_sda\"/> <vbd device=\"sdb\" function=\"swap\" mode=\"w\" vdi=\"vdi_sdb\"/> </vm> <vdi name=\"vdi_sda\" size=\"5368709120\" source=\"file://sda\" type=\"dir-gzippedchunks\"/> <vdi name=\"vdi_sdb\" size=\"536870912\" source=\"file://sdb\" type=\"dir-gzippedchunks\"/> </appliance> RPC notes Datetimes The API deviates from the RPC specification in handling of datetimes. The API appends a \"Z\" to the end of datetime strings, which is meant to indicate that the time is expressed in UTC. Where to look next In this chapter we have presented a brief high-level overview of the API and its object-model. The aim here is not to present the detailed semantics of the API, but just to provide enough background for you to start reading the code samples of the next chapter and to find your way around the more detailed Citrix Hypervisor Management API reference. There are a number of places you can find more information: The Citrix Hypervisor Product Documentation contains an overview of the xe CLI. Since a good deal of xe commands are a thin veneer over the API, playing with xe is a good way to start finding your way around the API object model described in this chapter. The code samples in the next chapter provide some concrete instances of API coding in a variety of client languages. The Citrix Hypervisor Management API reference provides a more detailed description of the API semantics as well as the wire protocol of the RPC messages. There are a few scripts that use the API in the Citrix Hypervisor server dom0 itself. For example, \"/opt/xensource/libexec/shutdown\" is a python program that cleanly shuts VMs down. This script is invoked when the host itself is shut down.","title":"Overview"},{"location":"overview/#overview-of-the-citrix-hypervisor-management-api","text":"This chapter introduces the Citrix Hypervisor Management API (after here referred to as the \"API\") and its associated object model. The API has the following key features: Management of all aspects of the Citrix Hypervisor server. The API allows you to manage VMs, storage, networking, host configuration, and pools. Performance and status metrics can also be queried from the API. Persistent Object Model. The results of all side-effecting operations (for example: object creation, deletion, and parameter changes) are persisted in a server-side database that is managed by Citrix Hypervisor. An event mechanism. Through the API, clients can register to be notified when persistent (server-side) objects are changed. This enables applications to track datamodel changes performed by concurrently executing clients. Synchronous and asynchronous invocation. All API calls can be invoked synchronously (that is, block until completion). Any API call that might be long-running can also be invoked asynchronously . Asynchronous calls return immediately with a reference to a task object. This task object can be queried (through the API) for progress and status information. When an asynchronously invoked operation completes, the result (or error code) is available from the task object. Remotable and Cross-Platform. The client issuing the API calls doesn't have to be resident on the host being managed. The client also does not have to be connected to the host over ssh to execute the API. API calls use the RPC protocol to transmit requests and responses over the network. Secure and Authenticated Access. The RPC API backend executing on the host accepts secure socket connections. This allows a client to execute the APIs over the https protocol. Further, all the API calls execute in the context of a login session generated through user name and password validation at the server. This provides secure and authenticated access to the Citrix Hypervisor installation.","title":"Overview of the Citrix Hypervisor Management API"},{"location":"overview/#citrix-hypervisor-management-api-deprecation-policy","text":"Items that will be removed in a future release are marked as deprecated. By default, Citrix continues to support deprecated APIs and product functionality up to and including the next Citrix Hypervisor Long Term Service Release (LTSR). Deprecated items are usually removed in a Current Release following that LTSR. In exceptional cases, an item might be deprecated and removed before the next LTSR. For example, a change might be required to improve security. If this happens, Citrix makes customers aware of the change to the API or the product functionality. This deprecation policy applies only to APIs and functionality that are documented at the following locations: Citrix Product Documentation Citrix Developer Documentation","title":"Citrix Hypervisor Management API Deprecation Policy"},{"location":"overview/#getting-started-with-the-api","text":"Let's start our tour of the API by describing the calls required to create a VM on a Citrix Hypervisor installation, and take it through a start/suspend/resume/stop cycle. This section does not reference code in any specific language. At this stage we just describe the informal sequence of RPC invocations that do our \"install and start\" task. Note We recommend strongly against using the VM.create call, which might be removed or changed in a future version of the API. Read on to learn other ways to make a new VM.","title":"Getting Started with the API"},{"location":"overview/#authentication-acquiring-a-session-reference","text":"The first step is to call Session.login_with_password(username, password, client_API_version, originator) . The API is session based, so before you can make other calls you must authenticate with the server. Assuming the user name and password are authenticated correctly, the result of this call is a session reference . Subsequent API calls take the session reference as a parameter. In this way, we ensure that only API users who are suitably authorized can perform operations on a Citrix Hypervisor installation. You can continue to use the same session for any number of API calls. When you have finished the session, recommends that you call Session.logout(session) to clean up: see later.","title":"Authentication: acquiring a session reference"},{"location":"overview/#acquiring-a-list-of-templates-to-base-a-new-vm-installation-on","text":"The next step is to query the list of \"templates\" on the host. Templates are specially marked VM objects that specify suitable default parameters for various supported guest types. (If you want to see a quick enumeration of the templates on a Citrix Hypervisor installation for yourself, you can execute the xe template-list CLI command.) To get a list of templates from the API, find the VM objects on the server that have their is_a_template field set to true. One way to do find these objects is by calling VM.get_all_records(session) where the session parameter is the reference we acquired from our Session.login_with_password call earlier. This call queries the server, returning a snapshot (taken at the time of the call) containing all the VM object references and their field values. (Remember that at this stage we are not concerned with how the returned object references and field values can be manipulated in any particular client language: that detail is dealt with by each language-specific SDK and described concretely in the following chapter. For now, assume the existence of an abstract mechanism for reading and manipulating objects and field values returned by API calls.) Now we have a snapshot of the VM objects' field values in the memory of our client application, iterate through them and find the VMs that have their is_a_template value set to true . At this stage, let's assume that our example application further iterates through the template objects and remembers the reference corresponding to the one that has its \" name_label \" set to \"Debian Etch 4.0\" (one of the default Linux templates supplied with Citrix Hypervisor).","title":"Acquiring a list of templates to base a new VM installation on"},{"location":"overview/#installing-the-vm-based-on-a-template","text":"Continuing through our example, we must now install a new VM based on the template we selected. The installation process requires two API calls: First we must now invoke the API call VM.clone(session, t_ref, \"my first VM\") . This call tells the server to clone the VM object referenced by t_ref to make a new VM object. The return value of this call is the VM reference corresponding to the newly created VM. Let's call this new_vm_ref . At this stage, the object referred to by new_vm_ref is still a template (like the VM object referred to by t_ref , from which it was cloned). To make new_vm_ref into a VM object, we must call VM.provision(session, new_vm_ref) . When this call returns the new_vm_ref object will have had its is_a_template field set to false, indicating that new_vm_ref now refers to a regular VM ready for starting. Note The provision operation can take a few minutes, as it is as during this call that the template's disk images are created. For the Debian template, the newly created disks are also at this stage populated with a Debian root filesystem.","title":"Installing the VM based on a template"},{"location":"overview/#taking-the-vm-through-a-startsuspendresumestop-cycle","text":"Now we have an object reference representing our newly installed VM, it is trivial to take it through a few lifecycle operations: To start our VM, we can call VM.start(session, new_vm_ref) After it's running, we can suspend it by calling VM.suspend(session, new_vm_ref) , We can resume it by calling VM.resume(session, new_vm_ref) . We can call VM.shutdown(session, new_vm_ref) to shut down the VM cleanly.","title":"Taking the VM through a start/suspend/resume/stop cycle"},{"location":"overview/#logging-out","text":"When an application is finished interacting with a Citrix Hypervisor server, it is good practice to call Session.logout(session) . This call invalidates the session reference (so it cannot be used in subsequent API calls) and deallocates server-side memory used to store the session object. Although inactive sessions eventually time out, the server has a hardcoded limit of 500 concurrent sessions for each username or originator . After this limit has been reached, fresh logins evict the session objects that have been used least recently. The session references of these evicted session objects become invalid. For successful interoperability with other applications, concurrently accessing the server, the best policy is: Choose a string that identifies your application and its version. Create a single session at start-of-day, using that identifying string for the originator parameter to Session.login_with_password . Use this session throughout the application and then explicitly logout when possible. Note: Sessions can be used across multiple separate client-server network connections . If a poorly written client leaks sessions or otherwise exceeds the limit, then as long as the client uses an appropriate originator argument, it is easily identifiable from the Citrix Hypervisor logs. Citrix Hypervisor destroys the longest-idle sessions of the rogue client only. This behavior might cause problems for that client but not for other clients. If the misbehaving client doesn't specify an originator , it is harder to identify and causes the premature destruction of other client sessions that also didn't specify an originator","title":"Logging out"},{"location":"overview/#install-and-start-example-summary","text":"We have seen how the API can be used to install a VM from a Citrix Hypervisor template and perform various lifecycle operations on it. Note that the number of calls we had to make to affect these operations was small: One call to acquire a session: Session.login_with_password() One call to query the VM (and template) objects present on the Citrix Hypervisor installation: VM.get_all_records() . Recall that we used the information returned from this call to select a suitable template to install from. Two calls to install a VM from our chosen template: VM.clone() , followed by VM.provision() . One call to start the resultant VM: VM.start() (and similarly other single calls to suspend, resume, and shut down accordingly) And then one call to log out Session.logout() Although the API as a whole is complex and fully featured, common tasks (such as VM lifecycle operations) are straightforward, requiring only a few simple API calls. Keep this fact in mind as you study the next section which might, on first reading, appear a little daunting!","title":"Install and start example: summary"},{"location":"overview/#object-model-overview","text":"This section gives a high-level overview of the object model of the API. For a more detailed description of the parameters and methods of each class, see the Citrix Hypervisor Management API reference. We start by giving a brief outline of some of the core classes that make up the API. (Don't worry if these definitions seem abstract in their initial presentation. The textual description in the following sections, and the code-sample walk through in the next section make these concepts concrete.)","title":"Object Model Overview"},{"location":"overview/#vm","text":"A VM object represents a particular virtual machine instance on a Citrix Hypervisor server or Resource Pool. Example methods include start , suspend , pool_migrate ; example parameters include power_state , memory_static_max , and name_label . (In the previous section we saw how the VM class is used to represent both templates and regular VMs)","title":"VM"},{"location":"overview/#host","text":"A host object represents a physical host in a Citrix Hypervisor pool. Example methods include reboot and shutdown . Example parameters include software_version , hostname , and [IP] address .","title":"Host"},{"location":"overview/#vdi","text":"A VDI object represents a Virtual Disk Image . Virtual Disk Images can be attached to VMs. A block device appears inside the VM through which the bits encapsulated by the attached Virtual Disk Image can be read and written. Example methods of the VDI class include resize and clone . Example fields include virtual_size and sharable . When we called VM.provision on the VM template in our previous example, some VDI objects were automatically created to represent the newly created disks. These VDIs were attached to the VM object.","title":"VDI"},{"location":"overview/#sr","text":"An SR ( Storage Repository ) aggregates a collection of VDIs, It encapsulates the properties of physical storage on which the VDIs' bits reside. Example parameters include: type which determines the storage-specific driver a Citrix Hypervisor installation uses to read/write the SR's VDIs physical_utilisation Example methods include scan which invokes the storage-specific driver to acquire a list of the VDIs contained with the SR and the properties of these VDIs create which initializes a block of physical storage so it is ready to store VDIs","title":"SR"},{"location":"overview/#network","text":"A network object represents a layer-2 network that exists in the environment in which the Citrix Hypervisor server instance lives. Since Citrix Hypervisor does not manage networks directly, network is a lightweight class that models physical and virtual network topology. VM and Host objects that are attached to a particular Network object can send network packets to each other. The objects are attached through VIF and PIF instances. For more information, see the following section. If you are finding this enumeration of classes rather terse, you can skip to the code walk-throughs of the next chapter. There are plenty of useful applications that can be written using only a subset of the classes already described. If you want to continue this description of classes in the abstract, read on. In addition to the classes listed in the previous section, there are four more that act as connectors . These connectors specify relationships between VMs and Hosts and Storage and Networks. The first two of these classes that we consider, VBD and VIF , determine how VMs are attached to virtual disks and network objects respectively.","title":"Network"},{"location":"overview/#vbd","text":"A VBD ( Virtual Block Device ) object represents an attachment between a VM and a VDI. When a VM is booted, its VBD objects are queried to determine which disk images (VDIs) to attach. Example methods of the VBD class include: plug which hot plugs a disk device into a running VM, making the specified VDI accessible therein unplug which hot unplugs a disk device from a running guest Example fields include: device which determines the device name inside the guest under which the specified VDI is made accessible","title":"VBD"},{"location":"overview/#vif","text":"A VIF ( Virtual Network Interface ) object represents an attachment between a VM and a Network object. When a VM is booted, its VIF objects are queried to determine which network devices to create. Example methods of the VIF class include: plug which hot plugs a network device into a running VM unplug which hot unplugs a network device from a running guest The second set of \"connector classes\" that we consider determine how Hosts are attached to Networks and Storage.","title":"VIF"},{"location":"overview/#pif","text":"A PIF ( Physical Interface ) object represents an attachment between a Host and a Network object. If a host is connected to a Network over a PIF, packets from the specified host can be transmitted/received by the corresponding host. Example fields of the PIF class include: device which specifies the device name to which the PIF corresponds. For example, eth0 MAC which specifies the MAC address of the underlying NIC that a PIF represents PIFs abstract both physical interfaces and VLANs (the latter distinguished by the existence of a positive integer in the \"VLAN\" field).","title":"PIF"},{"location":"overview/#pbd","text":"A PBD ( Physical Block Device ) object represents an attachment between a Host and an SR (Storage Repository) object. Fields include: currently-attached which specifies whether the chunk of storage represented by the specified SR object is available to the host device_config which specifies storage-driver specific parameters that determine how the low-level storage devices are configured on the specified host. For example, when an SR rendered on an NFS filer, device_config can specify the host-name of the filer and the path on the filer in which the SR files live. This figure presents a graphical overview of the API classes involved in managing VMs, Hosts, Storage, and Networking. From this diagram, the symmetry between storage and network configuration, and also the symmetry between virtual machine and host configuration is plain to see.","title":"PBD"},{"location":"overview/#working-with-vifs-and-vbds","text":"In this section we walk through a few more complex scenarios. These scenarios describe how various tasks involving virtual storage and network devices can be done using the API.","title":"Working with VIFs and VBDs"},{"location":"overview/#creating-disks-and-attaching-them-to-vms","text":"Let's start by considering how to make a new blank disk image and attach it to a running VM. We assume that we already have a running VM, and we know its corresponding API object reference. For example, we might have created this VM using the procedure described in the previous section and had the server return its reference to us. We also assume that we have authenticated with the Citrix Hypervisor installation and have a corresponding session reference . Indeed in the rest of this chapter, for the sake of brevity, does not mention sessions altogether.","title":"Creating disks and attaching them to VMs"},{"location":"overview/#creating-a-new-blank-disk-image","text":"First, instantiate the disk image on physical storage by calling VDI.create() . The VDI.create call takes a number of parameters, including: name_label and name_description : a human-readable name/description for the disk (for example, for convenient display in the UI). These fields can be left blank if desired. SR : the object reference of the Storage Repository representing the physical storage in which the VDI's bits are placed. read_only : setting this field to true indicates that the VDI can only be attached to VMs in a read-only fashion. (Attempting to attach a VDI with its read_only field set to true in a read/write fashion results in error.) Invoking the VDI.create call causes the Citrix Hypervisor installation to create a blank disk image on physical storage, create an associated VDI object (the datamodel instance that refers to the disk image on physical storage) and return a reference to this newly created VDI object. The way in which the disk image is represented on physical storage depends on the type of the SR in which the created VDI resides. For example, if the SR is of type \"lvm\" then the new disk image will be rendered as an LVM volume; if the SR is of type \"nfs\" then the new disk image will be a sparse VHD file created on an NFS filer. (You can query the SR type through the API using the SR.get_type() call.) Note Some SR types might round up the virtual-size value to make it divisible by a configured block size.","title":"Creating a new blank disk image"},{"location":"overview/#attaching-the-disk-image-to-a-vm","text":"So far we have a running VM (that we assumed the existence of at the start of this example) and a fresh VDI that we just created. Right now, these are both independent objects that exist on the Citrix Hypervisor Host, but there is nothing linking them together. So our next step is to create such a link, associating the VDI with our VM. The attachment is formed by creating a new \"connector\" object called a VBD ( Virtual Block Device ). To create our VBD we invoke the VBD.create() call. The VBD.create() call takes a number of parameters including: VM - the object reference of the VM to which the VDI is to be attached VDI - the object reference of the VDI that is to be attached mode - specifies whether the VDI is to be attached in a read-only or a read-write fashion userdevice - specifies the block device inside the guest through which applications running inside the VM will be able to read/write the VDI's bits. type - specifies whether the VDI should be presented inside the VM as a regular disk or as a CD. (Note that this particular field has more meaning for Windows VMs than it does for Linux VMs, but we will not explore this level of detail in this chapter.) Invoking VBD.create makes a VBD object on the Citrix Hypervisor installation and returns its object reference. However, this call in itself does not have any side-effects on the running VM (that is, if you go and look inside the running VM you will see that the block device has not been created). The fact that the VBD object exists but that the block device in the guest is not active, is reflected by the fact that the VBD object's currently_attached field is set to false. For expository purposes, this figure presents a graphical example that shows the relationship between VMs, VBDs, VDIs and SRs. In this instance a VM object has 2 attached VDIs: there are two VBD objects that form the connections between the VM object and its VDIs; and the VDIs reside within the same SR.","title":"Attaching the disk image to a VM"},{"location":"overview/#hotplugging-the-vbd","text":"If we rebooted the VM at this stage then, after rebooting, the block device corresponding to the VBD would appear: on boot, Citrix Hypervisor queries all VBDs of a VM and actively attaches each of the corresponding VDIs. Rebooting the VM is all very well, but recall that we wanted to attach a newly created blank disk to a running VM. This can be achieved by invoking the plug method on the newly created VBD object. When the plug call returns successfully, the block device to which the VBD relates will have appeared inside the running VM -- i.e. from the perspective of the running VM, the guest operating system is led to believe that a new disk device has just been hot plugged . Mirroring this fact in the managed world of the API, the currently_attached field of the VBD is set to true. Unsurprisingly, the VBD plug method has a dual called \" unplug \". Invoking the unplug method on a VBD object causes the associated block device to be hot unplugged from a running VM, setting the currently_attached field of the VBD object to false accordingly.","title":"Hotplugging the VBD"},{"location":"overview/#creating-and-attaching-network-devices-to-vms","text":"The API calls involved in configuring virtual network interfaces in VMs are similar in many respects to the calls involved in configuring virtual disk devices. For this reason we will not run through a full example of how one can create network interfaces using the API object-model; instead we will use this section just to outline briefly the symmetry between virtual networking device and virtual storage device configuration. The networking analogue of the VBD class is the VIF class. Just as a VBD is the API representation of a block device inside a VM, a VIF ( Virtual network InterFace ) is the API representation of a network device inside a VM. Whereas VBDs associate VM objects with VDI objects, VIFs associate VM objects with Network objects. Just like VBDs, VIFs have a currently_attached field that determines whether or not the network device (inside the guest) associated with the VIF is currently active or not. And as we saw with VBDs, at VM boot-time the VIFs of the VM are queried and a corresponding network device for each created inside the booting VM. Similarly, VIFs also have plug and unplug methods for hot plugging/unplugging network devices in/out of running VMs.","title":"Creating and attaching Network Devices to VMs"},{"location":"overview/#host-configuration-for-networking-and-storage","text":"We have seen that the VBD and VIF classes are used to manage configuration of block devices and network devices (respectively) inside VMs. To manage host configuration of storage and networking there are two analogous classes: PBD ( Physical Block Device ) and PIF ( Physical [network] InterFace ).","title":"Host configuration for networking and storage"},{"location":"overview/#host-storage-configuration-pbds","text":"Let us start by considering the PBD class. A PBD_create() call takes a number of parameters including: Parameter Description host physical machine on which the PBD is available SR the Storage Repository that the PBD connects to device_config a string-to-string map that is provided to the host's SR-backend-driver, containing the low-level parameters required to configure the physical storage device(s) on which the SR is to be realized. The specific contents of the device_config field depend on the type of the SR to which the PBD is connected. (Executing xe sm-list will show a list of possible SR types; the configuration field in this enumeration specifies the device_config parameters that each SR type expects.) For example, imagine we have an SR object s of type \"nfs\" (representing a directory on an NFS filer within which VDIs are stored as VHD files); and let's say that we want a host, h , to be able to access s . In this case we invoke PBD.create() specifying host h , SR s , and a value for the device_config parameter that is the following map: (\"server\", \"my_nfs_server.example.com\"), (\"serverpath\", \"/scratch/mysrs/sr1\") This tells the Citrix Hypervisor server that SR s is accessible on host h , and further that to access SR s , the host needs to mount the directory /scratch/mysrs/sr1 on the NFS server named my_nfs_server.example.com . Like VBD objects, PBD objects also have a field called currently_attached . Storage repositories can be attached and detached from a given host by invoking PBD.plug and PBD.unplug methods respectively.","title":"Host storage configuration: PBDs"},{"location":"overview/#host-networking-configuration-pifs","text":"Host network configuration is specified by virtue of PIF objects. If a PIF object connects a network object, n , to a host object h , then the network corresponding to n is bridged onto a physical interface (or a physical interface plus a VLAN tag) specified by the fields of the PIF object. For example, imagine a PIF object exists connecting host h to a network n , and that device field of the PIF object is set to eth0 . This means that all packets on network n are bridged to the NIC in the host corresponding to host network device eth0 .","title":"Host networking configuration: PIFs"},{"location":"overview/#exporting-and-importing-vms","text":"VMs can be exported to a file and later imported to any Citrix Hypervisor server. The export protocol is a simple HTTP(S) GET, which should be performed on the master if the VM is on a pool member. Authorization is either standard HTTP basic authentication, or if a session has already been obtained, this can be used. The VM to export is specified either by UUID or by reference. To keep track of the export, a task can be created and passed in using its reference. The request might result in a redirect if the VM's disks are only accessible on a pool member. The following arguments are passed on the command line: Argument Description session_id the reference of the session being used to authenticate; required only when not using HTTP basic authentication task_id the reference of the task object with which to keep track of the operation; optional, required only if you have created a task object to keep track of the export ref the reference of the VM; required only if not using the UUID uuid the UUID of the VM; required only if not using the reference For example, using the Linux command line tool cURL: curl http://root:foo@myhypervisor1/export?uuid=<vm_uuid> -o <exportfile> This command will export the specified VM to the file exportfile . To export just the metadata, use the URI http://server/export_metadata . The import protocol is similar, using HTTP(S) PUT. The session_id and task_id arguments are as for the export. The ref and uuid are not used; a new reference and uuid will be generated for the VM. There are some additional parameters: Argument Description restore if true , the import is treated as replacing the original VM - the implication of this currently is that the MAC addresses on the VIFs are exactly as the export was, which will lead to conflicts if the original VM is still being run. force if true , any checksum failures will be ignored (the default is to destroy the VM if a checksum error is detected) sr_id the reference of an SR into which the VM should be imported. The default behavior is to import into the Pool.default_SR . For example, again using cURL: curl -T <exportfile> http://root:foo@myhypervisor2/import This command will import the VM to the default SR on the server. Note Note that if no default SR has been set, and no sr_uuid is specified, the error message \"DEFAULT_SR_NOT_FOUND\" is returned. Another example: curl -T <exportfile> http://root:foo@myhypervisor2/import?sr_id=<opaque_ref_of_sr> This command will import the VM to the specified SR on the server. To import just the metadata, use the URI http://server/import_metadata","title":"Exporting and Importing VMs"},{"location":"overview/#xen-virtual-appliance-xva-vm-import-format","text":"Citrix Hypervisor supports a human-readable legacy VM input format called XVA. This section describes the syntax and structure of XVA. An XVA consists of a directory containing XML metadata and a set of disk images. A VM represented by an XVA is not intended to be directly executable. Data within an XVA package is compressed and intended for either archiving on permanent storage or for being transmitted to a VM server - such as a Citrix Hypervisor server - where it can be decompressed and executed. XVA is a hypervisor-neutral packaging format; it should be possible to create simple tools to instantiate an XVA VM on any other platform. XVA does not specify any particular runtime format; for example disks may be instantiated as file images, LVM volumes, QCoW images, VMDK or VHD images. An XVA VM may be instantiated any number of times, each instantiation may have a different runtime format. XVA does not: specify any particular serialization or transport format provide any mechanism for customizing VMs (or templates) on install address how a VM may be upgraded post-install define how multiple VMs, acting as an appliance, may communicate These issues are all addressed by the related Open Virtual Appliance specification. An XVA is a directory containing, at a minimum, a file called ova.xml . This file describes the VM contained within the XVA and is described in Section 3.2. Disks are stored within sub-directories and are referenced from the ova.xml. The format of disk data is described in a later section. The following terms are used in the rest of this article: HVM: a mode in which unmodified OS kernels run with the help of virtualization support in the hardware. PV: a mode in which specially modified \"paravirtualized\" kernels run explicitly on top of a hypervisor without requiring hardware support for virtualization. The \"ova.xml\" file contains the following elements: <appliance version=\"0.1\"> The number in the attribute \"version\" indicates the version of this specification to which the XVA is constructed; in this case version 0.1. Inside the <appliance> there is exactly one <vm>: (in the OVA specification, multiple <vm>s are permitted) <vm name=\"name\"> Each <vm> element describes one VM. The \"name\" attribute is for future internal use only and must be unique within the ova.xml file. The \"name\" attribute is permitted to be any valid UTF-8 string. Inside each <vm> tag are the following compulsory elements: <label>... text ... </label> A short name for the VM to be displayed in a UI. <shortdesc> ... description ... </shortdesc> A description for the VM to be displayed in the UI. Note that for both <label> and <shortdesc> contents, leading and trailing whitespace will be ignored. <config mem_set=\"268435456\" vcpus=\"1\"/> The <config> element has attributes which describe the amount of memory in bytes (mem_set) and number of CPUs (VCPUs) the VM should have. Each <vm> has zero or more <vbd> elements representing block devices which look like the following: <vbd device=\"sda\" function=\"root\" mode=\"w\" vdi=\"vdi_sda\"/> The attributes have the following meanings: device name of the physical device to expose to the VM. For linux guests we use \"sd[a-z]\" and for windows guests we use \"hd[a-d]\". function if marked as \"root\", this disk will be used to boot the guest. (NB this does not imply the existence of the Linux root i.e. / filesystem) Only one device should be marked as \"root\". See Section 3.4 describing VM booting. Any other string is ignored. mode either \"w\" or \"ro\" if the device is to be read/write or read-only vdi the name of the disk image (represented by a <vdi> element) to which this block device is connected Each <vm> may have an optional <hacks> section like the following: <hacks is_hvm=\"false\" kernel_boot_cmdline=\"root=/dev/sda1 ro\"/> The <hacks> element is present in the XVA files generated by Citrix Hypervisor but will be removed in future. The attribute \"is_hvm\" is either \"true\" or \"false\", depending on whether the VM should be booted in HVM or not. The \"kernel_boot_cmdline\" contains additional kernel commandline arguments when booting a guest using pygrub. In addition to a <vm> element, the <appliance> will contain zero or more <vdi> elements like the following: <vdi name=\"vdi_sda\" size=\"5368709120\" source=\"file://sda\" type=\"dir-gzipped-chunks\"> Each <vdi> corresponds to a disk image. The attributes have the following meanings: name: name of the VDI, referenced by the vdi attribute of <vbd> elements. Any valid UTF-8 string is permitted. size: size of the required image in bytes source: a URI describing where to find the data for the image, only file:// URIs are currently permitted and must describe paths relative to the directory containing the ova.xml type: describes the format of the disk data A single disk image encoding is specified in which has type \"dir-gzipped-chunks\": Each image is represented by a directory containing a sequence of files as follows: -rw-r--r-- 1 dscott xendev 458286013 Sep 18 09:51 chunk000000000.gz -rw-r--r-- 1 dscott xendev 422271283 Sep 18 09:52 chunk000000001.gz -rw-r--r-- 1 dscott xendev 395914244 Sep 18 09:53 chunk000000002.gz -rw-r--r-- 1 dscott xendev 9452401 Sep 18 09:53 chunk000000003.gz -rw-r--r-- 1 dscott xendev 1096066 Sep 18 09:53 chunk000000004.gz -rw-r--r-- 1 dscott xendev 971976 Sep 18 09:53 chunk000000005.gz -rw-r--r-- 1 dscott xendev 971976 Sep 18 09:53 chunk000000006.gz -rw-r--r-- 1 dscott xendev 971976 Sep 18 09:53 chunk000000007.gz -rw-r--r-- 1 dscott xendev 573930 Sep 18 09:53 chunk000000008.gz Each file (named \"chunk-XXXXXXXXX.gz\") is a gzipped file containing exactly 1e9 bytes (1GB, not 1GiB) of raw block data. The small size was chosen to be safely under the maximum file size limits of several filesystems. If the files are gunzipped and then concatenated together, the original image is recovered. Citrix Hypervisor provides two mechanisms for booting a VM: (i) using a paravirtualized kernel extracted through pygrub; and (ii) using HVM. The current implementation uses the \"is_hvm\" flag within the <hacks> section to decide which mechanism to use. This rest of this section describes a very simple Debian VM packaged as an XVA. The VM has two disks, one with size 5120MiB and used for the root filesystem and used to boot the guest using pygrub and the other of size 512MiB which is used for swap. The VM has 512MiB of memory and uses one virtual CPU. At the topmost level the simple Debian VM is represented by a single directory: $ ls -l total 4 drwxr-xr-x 3 dscott xendev 4096 Oct 24 09:42 very simple Debian VM Inside the main XVA directory are two sub-directories - one per disk - and the single file: ova.xml: $ ls -l very\\ simple\\ Debian\\ VM/ total 8 -rw-r--r-- 1 dscott xendev 1016 Oct 24 09:42 ova.xml drwxr-xr-x 2 dscott xendev 4096 Oct 24 09:42 sda drwxr-xr-x 2 dscott xendev 4096 Oct 24 09:53 sdb Inside each disk sub-directory are a set of files, each file contains 1GB of raw disk block data compressed using gzip: $ ls -l very\\ simple\\ Debian\\ VM/sda/ total 2053480 -rw-r--r-- 1 dscott xendev 202121645 Oct 24 09:43 chunk-000000000.gz -rw-r--r-- 1 dscott xendev 332739042 Oct 24 09:45 chunk-000000001.gz -rw-r--r-- 1 dscott xendev 401299288 Oct 24 09:48 chunk-000000002.gz -rw-r--r-- 1 dscott xendev 389585534 Oct 24 09:50 chunk-000000003.gz -rw-r--r-- 1 dscott xendev 624567877 Oct 24 09:53 chunk-000000004.gz -rw-r--r-- 1 dscott xendev 150351797 Oct 24 09:54 chunk-000000005.gz $ ls -l very\\ simple\\ Debian\\ VM/sdb total 516 -rw-r--r-- 1 dscott xendev 521937 Oct 24 09:54 chunk-000000000.gz The example simple Debian VM would have an XVA file like the following: <?xml version=\"1.0\" ?> <appliance version=\"0.1\"> <vm name=\"vm\"> <label>very simple Debian VM</label> <shortdesc>the description field can contain any valid UTF-8</shortdesc> <config mem_set=\"536870912\" vcpus=\"1\"/> <hacks is_hvm=\"false\" kernel_boot_cmdline=\"root=/dev/sda1 ro \"> <!--This section is temporary and will be ignored in future. Attribute is_hvm (\"true\" or \"false\") indicates whether the VM will be booted in HVM mode. In future this will be autodetected. Attribute kernel_boot_cmdline contains the kernel commandline for the case where a proper grub menu.lst is not present. In future booting shall only use pygrub.--> </hacks> <vbd device=\"sda\" function=\"root\" mode=\"w\" vdi=\"vdi_sda\"/> <vbd device=\"sdb\" function=\"swap\" mode=\"w\" vdi=\"vdi_sdb\"/> </vm> <vdi name=\"vdi_sda\" size=\"5368709120\" source=\"file://sda\" type=\"dir-gzippedchunks\"/> <vdi name=\"vdi_sdb\" size=\"536870912\" source=\"file://sdb\" type=\"dir-gzippedchunks\"/> </appliance>","title":"Xen Virtual Appliance (XVA) VM Import Format"},{"location":"overview/#rpc-notes","text":"","title":"RPC notes"},{"location":"overview/#datetimes","text":"The API deviates from the RPC specification in handling of datetimes. The API appends a \"Z\" to the end of datetime strings, which is meant to indicate that the time is expressed in UTC.","title":"Datetimes"},{"location":"overview/#where-to-look-next","text":"In this chapter we have presented a brief high-level overview of the API and its object-model. The aim here is not to present the detailed semantics of the API, but just to provide enough background for you to start reading the code samples of the next chapter and to find your way around the more detailed Citrix Hypervisor Management API reference. There are a number of places you can find more information: The Citrix Hypervisor Product Documentation contains an overview of the xe CLI. Since a good deal of xe commands are a thin veneer over the API, playing with xe is a good way to start finding your way around the API object model described in this chapter. The code samples in the next chapter provide some concrete instances of API coding in a variety of client languages. The Citrix Hypervisor Management API reference provides a more detailed description of the API semantics as well as the wire protocol of the RPC messages. There are a few scripts that use the API in the Citrix Hypervisor server dom0 itself. For example, \"/opt/xensource/libexec/shutdown\" is a python program that cleanly shuts VMs down. This script is invoked when the host itself is shut down.","title":"Where to look next"},{"location":"using-http/","text":"Using HTTP to interact with Citrix Hypervisor Citrix Hypervisor exposes an HTTP interface on each host, that can be used to perform various operations. This chapter describes the available mechanisms. VM Import and Export Because the import and export of VMs can take some time to complete, an asynchronous HTTP interface to the import and export operations is provided. To perform an export using the Citrix Hypervisor Management API, construct an HTTP GET call providing a valid session ID, task ID and VM UUID, as shown in the following pseudo code: task = Task.create() result = HTTP.get(server, 80, \"/export?session_id=session_id&task_id=task_id&ref=vm_uuid\"); For the import operation, use an HTTP PUT call as demonstrated in the following pseudo code: task = Task.create() result = HTTP.put(server, 80, \"/import?session_id=session_id&task_id=task_id&ref=vm_uuid\"); Getting Citrix Hypervisor Performance Statistics Citrix Hypervisor records statistics about the performance of various aspects of your Citrix Hypervisor installation. The metrics are stored persistently for long term access and analysis of historical trends. Where storage is available to a VM, the statistics are written to disk when a VM is shut down. Statistics are stored in RRDs (Round Robin Databases), which are maintained for individual VMs (including the control domain) and the server. RRDs are resident on the server on which the VM is running, or the pool master when the VM is not running. The RRDs are also backed up every day. Warning In earlier versions of the Citrix Hypervisor Management API, instantaneous performance metrics could be obtained using the VM_metrics , VM_guest_metrics , host_metrics methods and associated methods. These methods has been deprecated in favor of using the http handler described in this chapter to download the statistics from the RRDs on the VMs and servers. Note that by default the legacy metrics will return zeroes. To revert to periodic statistical polling as present in earlier versions of Citrix Hypervisor, set the other-config:rrd_update_interval=interval parameters on your host to one of the following values, and restart your host: never : This is the default, meaning no periodic polling is performed. 1 : Polling is performed every 5 seconds. 2 : Polling is performed every minute. By default, the older metrics APIs will not return any values, and so this key must be enabled to run monitoring clients which use the legacy monitoring protocol. Statistics are persisted for a maximum of one year, and are stored at different granularities. The average and most recent values are stored at intervals of: 5 seconds for the past 10 minutes one minute for the past 2 hours one hour for the past week one day for the past year RRDs are saved to disk as uncompressed XML. The size of each RRD when written to disk ranges from 200KiB to approximately 1.2MiB when the RRD stores the full year of statistics. Warning If statistics cannot be written to disk, for example when a disk is full, statistics will be lost and the last saved version of the RRD will be used. Statistics can be downloaded over HTTP in XML format, for example using wget . See rrddump and rrdxport for information about the XML format. HTTP authentication can take the form of a username and password or a session token. Parameters are appended to the URL following a question mark (?) and separated by ampersands (&). To obtain an update of all VM statistics on a host, the URL would be of the form: http://username:password@host/rrd_updates?start=secondssinceepoch This request returns data in an rrdtool xport style XML format, for every VM resident on the particular host that is being queried. To differentiate which column in the export is associated with which VM, the legend field is prefixed with the UUID of the VM. To obtain host updates too, use the query parameter host=true : http://username:password@host/rrd_updates?start=secondssinceepoch&host=true The step will decrease as the period decreases, which means that if you request statistics for a shorter time period you will get more detailed statistics. Additional rrd_updates parameters cf= ave|min|max : the data consolidation mode interval= interval : the interval between values to be reported Note By default only ave statistics are available. To obtain min and max statistics for a VM, run the following command: xe pool-param-set uuid=pool_uuid other-config:create_min_max_in_new_VM_RRDs To obtain all statistics for a host: http://username:password@host/host_rrd To obtain all statistics for a VM: http://username:password@host/vm_rrd?uuid=vm_uuid","title":"Using HTTP"},{"location":"using-http/#using-http-to-interact-with-citrix-hypervisor","text":"Citrix Hypervisor exposes an HTTP interface on each host, that can be used to perform various operations. This chapter describes the available mechanisms.","title":"Using HTTP to interact with Citrix Hypervisor"},{"location":"using-http/#vm-import-and-export","text":"Because the import and export of VMs can take some time to complete, an asynchronous HTTP interface to the import and export operations is provided. To perform an export using the Citrix Hypervisor Management API, construct an HTTP GET call providing a valid session ID, task ID and VM UUID, as shown in the following pseudo code: task = Task.create() result = HTTP.get(server, 80, \"/export?session_id=session_id&task_id=task_id&ref=vm_uuid\"); For the import operation, use an HTTP PUT call as demonstrated in the following pseudo code: task = Task.create() result = HTTP.put(server, 80, \"/import?session_id=session_id&task_id=task_id&ref=vm_uuid\");","title":"VM Import and Export"},{"location":"using-http/#getting-citrix-hypervisor-performance-statistics","text":"Citrix Hypervisor records statistics about the performance of various aspects of your Citrix Hypervisor installation. The metrics are stored persistently for long term access and analysis of historical trends. Where storage is available to a VM, the statistics are written to disk when a VM is shut down. Statistics are stored in RRDs (Round Robin Databases), which are maintained for individual VMs (including the control domain) and the server. RRDs are resident on the server on which the VM is running, or the pool master when the VM is not running. The RRDs are also backed up every day. Warning In earlier versions of the Citrix Hypervisor Management API, instantaneous performance metrics could be obtained using the VM_metrics , VM_guest_metrics , host_metrics methods and associated methods. These methods has been deprecated in favor of using the http handler described in this chapter to download the statistics from the RRDs on the VMs and servers. Note that by default the legacy metrics will return zeroes. To revert to periodic statistical polling as present in earlier versions of Citrix Hypervisor, set the other-config:rrd_update_interval=interval parameters on your host to one of the following values, and restart your host: never : This is the default, meaning no periodic polling is performed. 1 : Polling is performed every 5 seconds. 2 : Polling is performed every minute. By default, the older metrics APIs will not return any values, and so this key must be enabled to run monitoring clients which use the legacy monitoring protocol. Statistics are persisted for a maximum of one year, and are stored at different granularities. The average and most recent values are stored at intervals of: 5 seconds for the past 10 minutes one minute for the past 2 hours one hour for the past week one day for the past year RRDs are saved to disk as uncompressed XML. The size of each RRD when written to disk ranges from 200KiB to approximately 1.2MiB when the RRD stores the full year of statistics. Warning If statistics cannot be written to disk, for example when a disk is full, statistics will be lost and the last saved version of the RRD will be used. Statistics can be downloaded over HTTP in XML format, for example using wget . See rrddump and rrdxport for information about the XML format. HTTP authentication can take the form of a username and password or a session token. Parameters are appended to the URL following a question mark (?) and separated by ampersands (&). To obtain an update of all VM statistics on a host, the URL would be of the form: http://username:password@host/rrd_updates?start=secondssinceepoch This request returns data in an rrdtool xport style XML format, for every VM resident on the particular host that is being queried. To differentiate which column in the export is associated with which VM, the legend field is prefixed with the UUID of the VM. To obtain host updates too, use the query parameter host=true : http://username:password@host/rrd_updates?start=secondssinceepoch&host=true The step will decrease as the period decreases, which means that if you request statistics for a shorter time period you will get more detailed statistics.","title":"Getting Citrix Hypervisor Performance Statistics"},{"location":"using-http/#additional-rrd_updates-parameters","text":"cf= ave|min|max : the data consolidation mode interval= interval : the interval between values to be reported Note By default only ave statistics are available. To obtain min and max statistics for a VM, run the following command: xe pool-param-set uuid=pool_uuid other-config:create_min_max_in_new_VM_RRDs To obtain all statistics for a host: http://username:password@host/host_rrd To obtain all statistics for a VM: http://username:password@host/vm_rrd?uuid=vm_uuid","title":"Additional rrd_updates parameters"},{"location":"using/","text":"Using the API This chapter describes how to use the Citrix Hypervisor Management API from real programs to manage Citrix Hypervisor servers and VMs. The chapter begins with a walk-through of a typical client application and demonstrates how the API can be used to perform common tasks. Example code fragments are given in python syntax but equivalent code in the other programming languages would look very similar. The chapter finishes with walk-throughs of two complete examples. Anatomy of a typical application This section describes the structure of a typical application using the Citrix Hypervisor Management API. Most client applications begin by connecting to a Citrix Hypervisor server and authenticating (for example, with a username and password). Assuming the authentication succeeds, the server will create a \"session\" object and return a reference to the client. This reference will be passed as an argument to all future API calls. Once authenticated, the client may search for references to other useful objects (for example, Citrix Hypervisor servers, VMs, etc.) and invoke operations on them. Operations may be invoked either synchronously or asynchronously; special task objects represent the state and progress of asynchronous operations. These application elements are all described in detail in the following sections. Choosing a low-level transport API calls can be issued over two transports: SSL-encrypted TCP on port 443 (https) over an IP network plaintext over a local Unix domain socket: /var/xapi/xapi Switching from the XML-RPC to the JSON-RPC backend can be done by adding the suffix /jsonrpc to the host URL path. The SSL-encrypted TCP transport is used for all off-host traffic while the Unix domain socket can be used from services running directly on the Citrix Hypervisor server itself. In the SSL-encrypted TCP transport, all API calls should be directed at the Resource Pool master; failure to do so will result in the error HOST_IS_SLAVE , which includes the IP address of the master as an error parameter. Because the master host of a pool can change, especially if HA is enabled on a pool, clients must implement the following steps to detect a master host change and connect to the new master as required: Handling pool master changes Subscribe to updates in the list of hosts servers, and maintain a current list of hosts in the pool If the connection to the pool master fails to respond, attempt to connect to all hosts in the list until one responds The first host to respond will return the HOST_IS_SLAVE error message, which contains the identity of the new pool master (unless of course the host is the new master) Connect to the new master Note As a special-case, all messages sent through the Unix domain socket are transparently forwarded to the correct node. Authentication and session handling The vast majority of API calls take a session reference as their first parameter; failure to supply a valid reference will result in a SESSION_INVALID error being returned. Acquire a session reference by supplying a username and password to the login_with_password function. Note As a special-case, if this call is executed over the local Unix domain socket then the username and password are ignored and the call always succeeds. Every session has an associated \"last active\" timestamp which is updated on every API call. The server software currently has a built-in limit of 500 active sessions and will remove those with the oldest \"last active\" field if this limit is exceeded for a given username or originator . In addition all sessions whose \"last active\" field is older than 24 hours are also removed. Therefore it is important to: Specify an appropriate originator when logging in; and Remember to log out of active sessions to avoid leaking them; and Be prepared to log in again to the server if a SESSION_INVALID error is caught. Note A session reference obtained by a login request to the XML-RPC backend can be used in subsequent requests to the JSON-RPC backend, and vice-versa. In the following Python fragment a connection is established over the Unix domain socket and a session is created: import XenAPI session = XenAPI.xapi_local() try: session.xenapi.login_with_password(\"root\", \"\", \"2.3\", \"My Widget v0.1\") ... finally: session.xenapi.session.logout() Finding references to useful objects Once an application has authenticated the next step is to acquire references to objects in order to query their state or invoke operations on them. All objects have a set of \"implicit\" messages which include the following: get_by_name_label : return a list of all objects of a particular class with a particular label; get_by_uuid : return a single object named by its UUID; get_all : return a set of references to all objects of a particular class; and get_all_records : return a map of reference to records for each object of a particular class. For example, to list all hosts: hosts = session.xenapi.host.get_all() To find all VMs with the name \"my first VM\": vms = session.xenapi.VM.get_by_name_label('my first VM') Note Object name_label fields are not guaranteed to be unique and so the get_by_name_label API call returns a set of references rather than a single reference. In addition to the methods of finding objects described above, most objects also contain references to other objects within fields. For example it is possible to find the set of VMs running on a particular host by calling: vms = session.xenapi.host.get_resident_VMs(host) Invoking synchronous operations on objects Once object references have been acquired, operations may be invoked on them. For example to start a VM: session.xenapi.VM.start(vm, False, False) All API calls are by default synchronous and will not return until the operation has completed or failed. For example in the case of VM.start the call does not return until the VM has started booting. Note When the VM.start call returns the VM will be booting. To determine when the booting has finished, wait for the in-guest agent to report internal statistics through the VM_guest_metrics object. Using Tasks to manage asynchronous operations To simplify managing operations which take quite a long time (for example, VM.clone and VM.copy ) functions are available in two forms: synchronous (the default) and asynchronous. Each asynchronous function returns a reference to a task object which contains information about the in-progress operation including: whether it is pending whether it is has succeeded or failed progress (in the range 0-1) the result or error code returned by the operation An application which wanted to track the progress of a VM.clone operation and display a progress bar would have code like the following: vm = session.xenapi.VM.get_by_name_label('my vm') task = session.xenapi.Async.VM.clone(vm) while session.xenapi.task.get_status(task) == \"pending\": progress = session.xenapi.task.get_progress(task) update_progress_bar(progress) time.sleep(1) session.xenapi.task.destroy(task) Note Note that a well-behaved client should remember to delete tasks created by asynchronous operations when it has finished reading the result or error. If the number of tasks exceeds a built-in threshold then the server will delete the oldest of the completed tasks. Subscribing to and listening for events With the exception of the task and metrics classes, whenever an object is modified the server generates an event. Clients can subscribe to this event stream on a per-class basis and receive updates rather than resorting to frequent polling. Events come in three types: add - generated when an object has been created; del - generated immediately before an object is destroyed; and mod - generated when an object's field has changed. Events also contain a monotonically increasing ID, the name of the class of object and a snapshot of the object state equivalent to the result of a get_record() . Clients register for events by calling event.register() with a list of class names or the special string \"*\". Clients receive events by executing event.next() which blocks until events are available and returns the new events. Note Since the queue of generated events on the server is of finite length a very slow client might fail to read the events fast enough; if this happens an EVENTS_LOST error is returned. Clients should be prepared to handle this by re-registering for events and checking that the condition they are waiting for hasn't become true while they were unregistered. The following Python code fragment demonstrates how to print a summary of every event generated by a system: (similar code exists in CitrixHypervisor-SDK/XenServerPython/samples/watch-all-events.py ) fmt = \"%8s %20s %5s %s\" session.xenapi.event.register([\"*\"]) while True: try: for event in session.xenapi.event.next(): name = \"(unknown)\" if \"snapshot\" in event.keys(): snapshot = event[\"snapshot\"] if \"name_label\" in snapshot.keys(): name = snapshot[\"name_label\"] print fmt % (event['id'], event['class'], event['operation'], name) except XenAPI.Failure, e: if e.details == [ \"EVENTS_LOST\" ]: print \"Caught EVENTS_LOST; should reregister\" Complete application examples This section describes two complete examples of real programs using the API. Simultaneously migrating VMs using live migration This python example (contained in CitrixHypervisor-SDK/XenServerPython/samples/permute.py ) demonstrates how to use live migration to move VMs simultaneously between hosts in a Resource Pool. The example makes use of asynchronous API calls and shows how to wait for a set of tasks to complete. The program begins with some standard boilerplate and imports the API module import sys, time import XenAPI Next the commandline arguments containing a server URL, username, password and a number of iterations are parsed. The username and password are used to establish a session which is passed to the function main , which is called multiple times in a loop. Note the use of try: finally: to make sure the program logs out of its session at the end. if __name__ == \"__main__\": if len(sys.argv) <> 5: print \"Usage:\" print sys.argv[0], \" <url> <username> <password> <iterations>\" sys.exit(1) url = sys.argv[1] username = sys.argv[2] password = sys.argv[3] iterations = int(sys.argv[4]) # First acquire a valid session by logging in: session = XenAPI.Session(url) session.xenapi.login_with_password(username, password, \"2.3\", \"Example migration-demo v0.1\") try: for i in range(iterations): main(session, i) finally: session.xenapi.session.logout() The main function examines each running VM in the system, taking care to filter out control domains (which are part of the system and not controllable by the user). A list of running VMs and their current hosts is constructed. def main(session, iteration): # Find a non-template VM object all = session.xenapi.VM.get_all() vms = [] hosts = [] for vm in all: record = session.xenapi.VM.get_record(vm) if not(record[\"is_a_template\"]) and \\ not(record[\"is_control_domain\"]) and \\ record[\"power_state\"] == \"Running\": vms.append(vm) hosts.append(record[\"resident_on\"]) print \"%d: Found %d suitable running VMs\" % (iteration, len(vms)) Next the list of hosts is rotated: # use a rotation as a permutation hosts = [hosts[-1]] + hosts[:(len(hosts)-1)] Each VM is then moved using live migration to the new host under this rotation (i.e. a VM running on host at position 2 in the list will be moved to the host at position 1 in the list etc.) In order to execute each of the movements in parallel, the asynchronous version of the VM.pool_migrate is used and a list of task references constructed. Note the live flag passed to the VM.pool_migrate ; this causes the VMs to be moved while they are still running. tasks = [] for i in range(0, len(vms)): vm = vms[i] host = hosts[i] task = session.xenapi.Async.VM.pool_migrate(vm, host, { \"live\": \"true\" }) tasks.append(task) The list of tasks is then polled for completion: finished = False records = {} while not(finished): finished = True for task in tasks: record = session.xenapi.task.get_record(task) records[task] = record if record[\"status\"] == \"pending\": finished = False time.sleep(1) Once all tasks have left the pending state (i.e. they have successfully completed, failed or been cancelled) the tasks are polled once more to see if they all succeeded: allok = True for task in tasks: record = records[task] if record[\"status\"] <> \"success\": allok = False If any one of the tasks failed then details are printed, an exception is raised and the task objects left around for further inspection. If all tasks succeeded then the task objects are destroyed and the function returns. if not(allok): print \"One of the tasks didn't succeed at\", \\ time.strftime(\"%F:%HT%M:%SZ\", time.gmtime()) idx = 0 for task in tasks: record = records[task] vm_name = session.xenapi.VM.get_name_label(vms[idx]) host_name = session.xenapi.host.get_name_label(hosts[idx]) print \"%s : %12s %s -> %s [ status: %s; result = %s; error = %s ]\" % \\ (record[\"uuid\"], record[\"name_label\"], vm_name, host_name, \\ record[\"status\"], record[\"result\"], repr(record[\"error_info\"])) idx = idx + 1 raise \"Task failed\" else: for task in tasks: session.xenapi.task.destroy(task) Cloning a VM using the xe CLI This example is a bash script which uses the xe CLI to clone a VM taking care to shut it down first if it is powered on. The example begins with some boilerplate which first checks if the environment variable XE has been set: if it has it assumes that it points to the full path of the CLI, else it is assumed that the xe CLI is on the current path. Next the script prompts the user for a server name, username and password: # Allow the path to the 'xe' binary to be overridden by the XE environment variable if [ -z \"${XE}\" ]; then XE=xe fi if [ ! -e \"${HOME}/.xe\" ]; then read -p \"Server name: \" SERVER read -p \"Username: \" USERNAME read -p \"Password: \" PASSWORD XE=\"${XE} -s ${SERVER} -u ${USERNAME} -pw ${PASSWORD}\" fi Next the script checks its commandline arguments. It requires exactly one: the UUID of the VM which is to be cloned: # Check if there's a VM by the uuid specified ${XE} vm-list params=uuid | grep -q \" ${vmuuid}$\" if [ $? -ne 0 ]; then echo \"error: no vm uuid \\\"${vmuuid}\\\" found\" exit 2 fi The script then checks the power state of the VM and if it is running, it attempts a clean shutdown. The event system is used to wait for the VM to enter state \"Halted\". Note The xe CLI supports a command-line argument --minimal which causes it to print its output without excess whitespace or formatting, ideal for use from scripts. If multiple values are returned they are comma-separated. # Check the power state of the vm name=$(${XE} vm-list uuid=${vmuuid} params=name-label --minimal) state=$(${XE} vm-list uuid=${vmuuid} params=power-state --minimal) wasrunning=0 # If the VM state is running, we shutdown the vm first if [ \"${state}\" = \"running\" ]; then ${XE} vm-shutdown uuid=${vmuuid} ${XE} event-wait class=vm power-state=halted uuid=${vmuuid} wasrunning=1 fi The VM is then cloned and the new VM has its name_label set to cloned_vm . # Clone the VM newuuid=$(${XE} vm-clone uuid=${vmuuid} new-name-label=cloned_vm) Finally, if the original VM had been running and was shutdown, both it and the new VM are started. # If the VM state was running before cloning, we start it again # along with the new VM. if [ \"$wasrunning\" -eq 1 ]; then ${XE} vm-start uuid=${vmuuid} ${XE} vm-start uuid=${newuuid} fi","title":"Using"},{"location":"using/#using-the-api","text":"This chapter describes how to use the Citrix Hypervisor Management API from real programs to manage Citrix Hypervisor servers and VMs. The chapter begins with a walk-through of a typical client application and demonstrates how the API can be used to perform common tasks. Example code fragments are given in python syntax but equivalent code in the other programming languages would look very similar. The chapter finishes with walk-throughs of two complete examples.","title":"Using the API"},{"location":"using/#anatomy-of-a-typical-application","text":"This section describes the structure of a typical application using the Citrix Hypervisor Management API. Most client applications begin by connecting to a Citrix Hypervisor server and authenticating (for example, with a username and password). Assuming the authentication succeeds, the server will create a \"session\" object and return a reference to the client. This reference will be passed as an argument to all future API calls. Once authenticated, the client may search for references to other useful objects (for example, Citrix Hypervisor servers, VMs, etc.) and invoke operations on them. Operations may be invoked either synchronously or asynchronously; special task objects represent the state and progress of asynchronous operations. These application elements are all described in detail in the following sections.","title":"Anatomy of a typical application"},{"location":"using/#choosing-a-low-level-transport","text":"API calls can be issued over two transports: SSL-encrypted TCP on port 443 (https) over an IP network plaintext over a local Unix domain socket: /var/xapi/xapi Switching from the XML-RPC to the JSON-RPC backend can be done by adding the suffix /jsonrpc to the host URL path. The SSL-encrypted TCP transport is used for all off-host traffic while the Unix domain socket can be used from services running directly on the Citrix Hypervisor server itself. In the SSL-encrypted TCP transport, all API calls should be directed at the Resource Pool master; failure to do so will result in the error HOST_IS_SLAVE , which includes the IP address of the master as an error parameter. Because the master host of a pool can change, especially if HA is enabled on a pool, clients must implement the following steps to detect a master host change and connect to the new master as required:","title":"Choosing a low-level transport"},{"location":"using/#handling-pool-master-changes","text":"Subscribe to updates in the list of hosts servers, and maintain a current list of hosts in the pool If the connection to the pool master fails to respond, attempt to connect to all hosts in the list until one responds The first host to respond will return the HOST_IS_SLAVE error message, which contains the identity of the new pool master (unless of course the host is the new master) Connect to the new master Note As a special-case, all messages sent through the Unix domain socket are transparently forwarded to the correct node.","title":"Handling pool master changes"},{"location":"using/#authentication-and-session-handling","text":"The vast majority of API calls take a session reference as their first parameter; failure to supply a valid reference will result in a SESSION_INVALID error being returned. Acquire a session reference by supplying a username and password to the login_with_password function. Note As a special-case, if this call is executed over the local Unix domain socket then the username and password are ignored and the call always succeeds. Every session has an associated \"last active\" timestamp which is updated on every API call. The server software currently has a built-in limit of 500 active sessions and will remove those with the oldest \"last active\" field if this limit is exceeded for a given username or originator . In addition all sessions whose \"last active\" field is older than 24 hours are also removed. Therefore it is important to: Specify an appropriate originator when logging in; and Remember to log out of active sessions to avoid leaking them; and Be prepared to log in again to the server if a SESSION_INVALID error is caught. Note A session reference obtained by a login request to the XML-RPC backend can be used in subsequent requests to the JSON-RPC backend, and vice-versa. In the following Python fragment a connection is established over the Unix domain socket and a session is created: import XenAPI session = XenAPI.xapi_local() try: session.xenapi.login_with_password(\"root\", \"\", \"2.3\", \"My Widget v0.1\") ... finally: session.xenapi.session.logout()","title":"Authentication and session handling"},{"location":"using/#finding-references-to-useful-objects","text":"Once an application has authenticated the next step is to acquire references to objects in order to query their state or invoke operations on them. All objects have a set of \"implicit\" messages which include the following: get_by_name_label : return a list of all objects of a particular class with a particular label; get_by_uuid : return a single object named by its UUID; get_all : return a set of references to all objects of a particular class; and get_all_records : return a map of reference to records for each object of a particular class. For example, to list all hosts: hosts = session.xenapi.host.get_all() To find all VMs with the name \"my first VM\": vms = session.xenapi.VM.get_by_name_label('my first VM') Note Object name_label fields are not guaranteed to be unique and so the get_by_name_label API call returns a set of references rather than a single reference. In addition to the methods of finding objects described above, most objects also contain references to other objects within fields. For example it is possible to find the set of VMs running on a particular host by calling: vms = session.xenapi.host.get_resident_VMs(host)","title":"Finding references to useful objects"},{"location":"using/#invoking-synchronous-operations-on-objects","text":"Once object references have been acquired, operations may be invoked on them. For example to start a VM: session.xenapi.VM.start(vm, False, False) All API calls are by default synchronous and will not return until the operation has completed or failed. For example in the case of VM.start the call does not return until the VM has started booting. Note When the VM.start call returns the VM will be booting. To determine when the booting has finished, wait for the in-guest agent to report internal statistics through the VM_guest_metrics object.","title":"Invoking synchronous operations on objects"},{"location":"using/#using-tasks-to-manage-asynchronous-operations","text":"To simplify managing operations which take quite a long time (for example, VM.clone and VM.copy ) functions are available in two forms: synchronous (the default) and asynchronous. Each asynchronous function returns a reference to a task object which contains information about the in-progress operation including: whether it is pending whether it is has succeeded or failed progress (in the range 0-1) the result or error code returned by the operation An application which wanted to track the progress of a VM.clone operation and display a progress bar would have code like the following: vm = session.xenapi.VM.get_by_name_label('my vm') task = session.xenapi.Async.VM.clone(vm) while session.xenapi.task.get_status(task) == \"pending\": progress = session.xenapi.task.get_progress(task) update_progress_bar(progress) time.sleep(1) session.xenapi.task.destroy(task) Note Note that a well-behaved client should remember to delete tasks created by asynchronous operations when it has finished reading the result or error. If the number of tasks exceeds a built-in threshold then the server will delete the oldest of the completed tasks.","title":"Using Tasks to manage asynchronous operations"},{"location":"using/#subscribing-to-and-listening-for-events","text":"With the exception of the task and metrics classes, whenever an object is modified the server generates an event. Clients can subscribe to this event stream on a per-class basis and receive updates rather than resorting to frequent polling. Events come in three types: add - generated when an object has been created; del - generated immediately before an object is destroyed; and mod - generated when an object's field has changed. Events also contain a monotonically increasing ID, the name of the class of object and a snapshot of the object state equivalent to the result of a get_record() . Clients register for events by calling event.register() with a list of class names or the special string \"*\". Clients receive events by executing event.next() which blocks until events are available and returns the new events. Note Since the queue of generated events on the server is of finite length a very slow client might fail to read the events fast enough; if this happens an EVENTS_LOST error is returned. Clients should be prepared to handle this by re-registering for events and checking that the condition they are waiting for hasn't become true while they were unregistered. The following Python code fragment demonstrates how to print a summary of every event generated by a system: (similar code exists in CitrixHypervisor-SDK/XenServerPython/samples/watch-all-events.py ) fmt = \"%8s %20s %5s %s\" session.xenapi.event.register([\"*\"]) while True: try: for event in session.xenapi.event.next(): name = \"(unknown)\" if \"snapshot\" in event.keys(): snapshot = event[\"snapshot\"] if \"name_label\" in snapshot.keys(): name = snapshot[\"name_label\"] print fmt % (event['id'], event['class'], event['operation'], name) except XenAPI.Failure, e: if e.details == [ \"EVENTS_LOST\" ]: print \"Caught EVENTS_LOST; should reregister\"","title":"Subscribing to and listening for events"},{"location":"using/#complete-application-examples","text":"This section describes two complete examples of real programs using the API.","title":"Complete application examples"},{"location":"using/#simultaneously-migrating-vms-using-live-migration","text":"This python example (contained in CitrixHypervisor-SDK/XenServerPython/samples/permute.py ) demonstrates how to use live migration to move VMs simultaneously between hosts in a Resource Pool. The example makes use of asynchronous API calls and shows how to wait for a set of tasks to complete. The program begins with some standard boilerplate and imports the API module import sys, time import XenAPI Next the commandline arguments containing a server URL, username, password and a number of iterations are parsed. The username and password are used to establish a session which is passed to the function main , which is called multiple times in a loop. Note the use of try: finally: to make sure the program logs out of its session at the end. if __name__ == \"__main__\": if len(sys.argv) <> 5: print \"Usage:\" print sys.argv[0], \" <url> <username> <password> <iterations>\" sys.exit(1) url = sys.argv[1] username = sys.argv[2] password = sys.argv[3] iterations = int(sys.argv[4]) # First acquire a valid session by logging in: session = XenAPI.Session(url) session.xenapi.login_with_password(username, password, \"2.3\", \"Example migration-demo v0.1\") try: for i in range(iterations): main(session, i) finally: session.xenapi.session.logout() The main function examines each running VM in the system, taking care to filter out control domains (which are part of the system and not controllable by the user). A list of running VMs and their current hosts is constructed. def main(session, iteration): # Find a non-template VM object all = session.xenapi.VM.get_all() vms = [] hosts = [] for vm in all: record = session.xenapi.VM.get_record(vm) if not(record[\"is_a_template\"]) and \\ not(record[\"is_control_domain\"]) and \\ record[\"power_state\"] == \"Running\": vms.append(vm) hosts.append(record[\"resident_on\"]) print \"%d: Found %d suitable running VMs\" % (iteration, len(vms)) Next the list of hosts is rotated: # use a rotation as a permutation hosts = [hosts[-1]] + hosts[:(len(hosts)-1)] Each VM is then moved using live migration to the new host under this rotation (i.e. a VM running on host at position 2 in the list will be moved to the host at position 1 in the list etc.) In order to execute each of the movements in parallel, the asynchronous version of the VM.pool_migrate is used and a list of task references constructed. Note the live flag passed to the VM.pool_migrate ; this causes the VMs to be moved while they are still running. tasks = [] for i in range(0, len(vms)): vm = vms[i] host = hosts[i] task = session.xenapi.Async.VM.pool_migrate(vm, host, { \"live\": \"true\" }) tasks.append(task) The list of tasks is then polled for completion: finished = False records = {} while not(finished): finished = True for task in tasks: record = session.xenapi.task.get_record(task) records[task] = record if record[\"status\"] == \"pending\": finished = False time.sleep(1) Once all tasks have left the pending state (i.e. they have successfully completed, failed or been cancelled) the tasks are polled once more to see if they all succeeded: allok = True for task in tasks: record = records[task] if record[\"status\"] <> \"success\": allok = False If any one of the tasks failed then details are printed, an exception is raised and the task objects left around for further inspection. If all tasks succeeded then the task objects are destroyed and the function returns. if not(allok): print \"One of the tasks didn't succeed at\", \\ time.strftime(\"%F:%HT%M:%SZ\", time.gmtime()) idx = 0 for task in tasks: record = records[task] vm_name = session.xenapi.VM.get_name_label(vms[idx]) host_name = session.xenapi.host.get_name_label(hosts[idx]) print \"%s : %12s %s -> %s [ status: %s; result = %s; error = %s ]\" % \\ (record[\"uuid\"], record[\"name_label\"], vm_name, host_name, \\ record[\"status\"], record[\"result\"], repr(record[\"error_info\"])) idx = idx + 1 raise \"Task failed\" else: for task in tasks: session.xenapi.task.destroy(task)","title":"Simultaneously migrating VMs using live migration"},{"location":"using/#cloning-a-vm-using-the-xe-cli","text":"This example is a bash script which uses the xe CLI to clone a VM taking care to shut it down first if it is powered on. The example begins with some boilerplate which first checks if the environment variable XE has been set: if it has it assumes that it points to the full path of the CLI, else it is assumed that the xe CLI is on the current path. Next the script prompts the user for a server name, username and password: # Allow the path to the 'xe' binary to be overridden by the XE environment variable if [ -z \"${XE}\" ]; then XE=xe fi if [ ! -e \"${HOME}/.xe\" ]; then read -p \"Server name: \" SERVER read -p \"Username: \" USERNAME read -p \"Password: \" PASSWORD XE=\"${XE} -s ${SERVER} -u ${USERNAME} -pw ${PASSWORD}\" fi Next the script checks its commandline arguments. It requires exactly one: the UUID of the VM which is to be cloned: # Check if there's a VM by the uuid specified ${XE} vm-list params=uuid | grep -q \" ${vmuuid}$\" if [ $? -ne 0 ]; then echo \"error: no vm uuid \\\"${vmuuid}\\\" found\" exit 2 fi The script then checks the power state of the VM and if it is running, it attempts a clean shutdown. The event system is used to wait for the VM to enter state \"Halted\". Note The xe CLI supports a command-line argument --minimal which causes it to print its output without excess whitespace or formatting, ideal for use from scripts. If multiple values are returned they are comma-separated. # Check the power state of the vm name=$(${XE} vm-list uuid=${vmuuid} params=name-label --minimal) state=$(${XE} vm-list uuid=${vmuuid} params=power-state --minimal) wasrunning=0 # If the VM state is running, we shutdown the vm first if [ \"${state}\" = \"running\" ]; then ${XE} vm-shutdown uuid=${vmuuid} ${XE} event-wait class=vm power-state=halted uuid=${vmuuid} wasrunning=1 fi The VM is then cloned and the new VM has its name_label set to cloned_vm . # Clone the VM newuuid=$(${XE} vm-clone uuid=${vmuuid} new-name-label=cloned_vm) Finally, if the original VM had been running and was shutdown, both it and the new VM are started. # If the VM state was running before cloning, we start it again # along with the new VM. if [ \"$wasrunning\" -eq 1 ]; then ${XE} vm-start uuid=${vmuuid} ${XE} vm-start uuid=${newuuid} fi","title":"Cloning a VM using the xe CLI"},{"location":"xc-api-extensions/","text":"XenCenter API Extensions The following section details the assumptions and API extensions that we have made, over and above the documented API. Extensions are encoded as particular key-value pairs in dictionaries such as VM.other_config . Pool Key Semantics pool.name_label An empty name_label indicates that the pool should be hidden on the tree view. pool.rolling_upgrade_in_progress Present if the pool is in the middle of a rolling upgrade. Host Key Semantics host.other_config[\"iscsi_iqn\"] The host's iSCSI IQN. host.license_params[\"expiry\"] The expiry date of the host's license, in ISO 8601, UTC. host.license_params[\"sku_type\"] The host license type i.e. Server or Enterprise. host.license_params[\"restrict_pooling\"] Returns true if pooling is restricted by the host. host.license_params[\"restrict_connection\"] The number of connections that can be made from XenCenter is restricted. host.license_params[\"restrict_qos\"] Returns true if Quality of Service settings are enabled on the host. host.license_params[\"restrict_vlan\"] Returns true if creation of virtual networks is restricted on the host. host.license_params[\"restrict_pool_attached_storage\"] Returns true if the creation of shared storage is restricted on this host. host.software_version[\"product_version\"] Returns the host's product version. host.software_version[\"build_number\"] Returns the host's build number. host.software_version[\"xapi\"] Returns the host's api revision number. host.software_version[\"package-linux\"] Returns \"installed\" if the Linux pack has been installed. host.software_version[\"oem_build_number\"] If the host is the OEM version, return its revision number. host.logging[\"syslog_destination\"] Gets or sets the destination for the Citrix Hypervisor system logger (null for local logging). host.logging[\"multipathing\"] \"true\" if storage multipathing is enabled on this host. host.logging[\"boot_time\"] A floating point Unix time giving the time that the host booted. host.logging[\"agent_start_time\"] A floating point Unix time giving the time that the control domain management daemon started. VM Key Semantics VM.other_config[\"default_template\"] This template is one that was installed by . This is used to selectively hide these in the tree view, to use a different icon for them, and to disallow deletion. VM.other_config[\"xensource_internal\"] This template is special, such as the P2V server template. These are completely hidden by the UI. VM.other_config[\"install_distro\"] == \"rhlike\" This template is for RHEL 5, or CentOS equivalents. This is used to prompt for the Install Repository during install, including support for install from ISO / CD, and to modify NFS URLs to suit these installers. VM.other_config[\"install-repository\"] == \"cdrom\" Requests an install from a repository in the VM's attached CD drive, rather than a URL. VM.other_config[\"auto_poweron\"] Gets or sets whether the VM starts when the server boots, \"true\" or \"false\". VM.other_config[\"ignore_excessive_vcpus\"] Gets or sets to ignore XenCenter warning if a VM has more VCPUs than its host has physical CPUs, true to ignore. VM.other_config[\"HideFromXenCenter\"] Gets or sets whether XenCenter will show the VM in the treeview, \"true\" to hide. VM.other_config[\"import_task\"] Gets the import task that created this VM. VM.HVM_boot_params[\"order\"] Gets or sets the VM's boot order on HVM VM's only, for example, \"CDN\" will boot in the following order - First boot disk, CD drive, Network. VM.VCPU_params[\"weight\"] Gets or sets the IONice value for the VM's VCPUs, ranges from 1 to 65536, 65536 being the highest. VM.pool_migrate(..., options['live']) true indicates live migration. XenCenter always uses this. VM.other_config[\"install-methods\"] A comma-separated list of install methods available for this template. Can include \"cdrom\", \"nfs\", \"http\" or \"ftp\". VM.other_config[\"last_shutdown_time\"] The time that this VM was last shut down or rebooted, formatted as a UTC ISO8601 datetime. VM.other_config[\"p2v_source_machine\"] The source machine, if this VM was imported by a P2V process. VM.other_config[\"p2v_import_date\"] The date the VM was imported, if it was imported by a P2V process. Formatted as a UTC ISO8601 datetime. SR Key Semantics SR.other_config[\"auto-scan\"] The SR will be automatically scanned for changes. Set on all SRs created by XenCenter. SR.sm_config[\"type\"] Set as type cd for SRs which are physical CD drives. VDI Key Semantics VDI.type user instead of system is used to mean \"do or do not allow deletion of the VDI through the GUI, if this disk is attached to a VM\". The intention here is to prevent you from corrupting a VM (you should uninstall it instead). suspend and crashdump record suspend and core dumps respectively. ephemeral is currently unused. VDI.managed All unmanaged VDIs are completely hidden in the UI. These are branch points in VHD chains, or unused LUN-per-VDI disks. VDI.sm_config[\"vmhint\"] The UUID of the VM that this VDI supports. This is set when VDIs are created through the user interface, to improve performance for certain storage backends. VBD Key Semantics VBD.other_config[\"owner\"] If set, then this disk may be deleted when the VM is uninstalled. VBD.other_config[\"class\"] Set to an integer, corresponding to the Best Effort setting of ionice . Network Key Semantics network.other_config[\"automatic\"] The New VM wizard will create a VIF connected to this network by default, if this key has any value other than false . network.other_config[\"import_task\"] Gets the import task that created this network. VM_guest_metrics Key Semantics PV_drivers_version[\"major\"] Gets the major version of the VM's PV drivers' version. PV_drivers_version[\"minor\"] Gets the minor version of the VM's PV drivers' version. PV_drivers_version[\"micro\"] Gets the micro (build number) of the VM's PV drivers' version. Task Key Semantics task.other_config[\"object_creation\"] == \"complete\" For the task associated with a VM import, this flag will be set when all the objects (VMs, networks) have been created. This is useful in the import VM wizard for us to then go and re-map all the networks that need it.","title":"XenCenter API Extension"},{"location":"xc-api-extensions/#xencenter-api-extensions","text":"The following section details the assumptions and API extensions that we have made, over and above the documented API. Extensions are encoded as particular key-value pairs in dictionaries such as VM.other_config .","title":"XenCenter API Extensions"},{"location":"xc-api-extensions/#pool","text":"Key Semantics pool.name_label An empty name_label indicates that the pool should be hidden on the tree view. pool.rolling_upgrade_in_progress Present if the pool is in the middle of a rolling upgrade.","title":"Pool"},{"location":"xc-api-extensions/#host","text":"Key Semantics host.other_config[\"iscsi_iqn\"] The host's iSCSI IQN. host.license_params[\"expiry\"] The expiry date of the host's license, in ISO 8601, UTC. host.license_params[\"sku_type\"] The host license type i.e. Server or Enterprise. host.license_params[\"restrict_pooling\"] Returns true if pooling is restricted by the host. host.license_params[\"restrict_connection\"] The number of connections that can be made from XenCenter is restricted. host.license_params[\"restrict_qos\"] Returns true if Quality of Service settings are enabled on the host. host.license_params[\"restrict_vlan\"] Returns true if creation of virtual networks is restricted on the host. host.license_params[\"restrict_pool_attached_storage\"] Returns true if the creation of shared storage is restricted on this host. host.software_version[\"product_version\"] Returns the host's product version. host.software_version[\"build_number\"] Returns the host's build number. host.software_version[\"xapi\"] Returns the host's api revision number. host.software_version[\"package-linux\"] Returns \"installed\" if the Linux pack has been installed. host.software_version[\"oem_build_number\"] If the host is the OEM version, return its revision number. host.logging[\"syslog_destination\"] Gets or sets the destination for the Citrix Hypervisor system logger (null for local logging). host.logging[\"multipathing\"] \"true\" if storage multipathing is enabled on this host. host.logging[\"boot_time\"] A floating point Unix time giving the time that the host booted. host.logging[\"agent_start_time\"] A floating point Unix time giving the time that the control domain management daemon started.","title":"Host"},{"location":"xc-api-extensions/#vm","text":"Key Semantics VM.other_config[\"default_template\"] This template is one that was installed by . This is used to selectively hide these in the tree view, to use a different icon for them, and to disallow deletion. VM.other_config[\"xensource_internal\"] This template is special, such as the P2V server template. These are completely hidden by the UI. VM.other_config[\"install_distro\"] == \"rhlike\" This template is for RHEL 5, or CentOS equivalents. This is used to prompt for the Install Repository during install, including support for install from ISO / CD, and to modify NFS URLs to suit these installers. VM.other_config[\"install-repository\"] == \"cdrom\" Requests an install from a repository in the VM's attached CD drive, rather than a URL. VM.other_config[\"auto_poweron\"] Gets or sets whether the VM starts when the server boots, \"true\" or \"false\". VM.other_config[\"ignore_excessive_vcpus\"] Gets or sets to ignore XenCenter warning if a VM has more VCPUs than its host has physical CPUs, true to ignore. VM.other_config[\"HideFromXenCenter\"] Gets or sets whether XenCenter will show the VM in the treeview, \"true\" to hide. VM.other_config[\"import_task\"] Gets the import task that created this VM. VM.HVM_boot_params[\"order\"] Gets or sets the VM's boot order on HVM VM's only, for example, \"CDN\" will boot in the following order - First boot disk, CD drive, Network. VM.VCPU_params[\"weight\"] Gets or sets the IONice value for the VM's VCPUs, ranges from 1 to 65536, 65536 being the highest. VM.pool_migrate(..., options['live']) true indicates live migration. XenCenter always uses this. VM.other_config[\"install-methods\"] A comma-separated list of install methods available for this template. Can include \"cdrom\", \"nfs\", \"http\" or \"ftp\". VM.other_config[\"last_shutdown_time\"] The time that this VM was last shut down or rebooted, formatted as a UTC ISO8601 datetime. VM.other_config[\"p2v_source_machine\"] The source machine, if this VM was imported by a P2V process. VM.other_config[\"p2v_import_date\"] The date the VM was imported, if it was imported by a P2V process. Formatted as a UTC ISO8601 datetime.","title":"VM"},{"location":"xc-api-extensions/#sr","text":"Key Semantics SR.other_config[\"auto-scan\"] The SR will be automatically scanned for changes. Set on all SRs created by XenCenter. SR.sm_config[\"type\"] Set as type cd for SRs which are physical CD drives.","title":"SR"},{"location":"xc-api-extensions/#vdi","text":"Key Semantics VDI.type user instead of system is used to mean \"do or do not allow deletion of the VDI through the GUI, if this disk is attached to a VM\". The intention here is to prevent you from corrupting a VM (you should uninstall it instead). suspend and crashdump record suspend and core dumps respectively. ephemeral is currently unused. VDI.managed All unmanaged VDIs are completely hidden in the UI. These are branch points in VHD chains, or unused LUN-per-VDI disks. VDI.sm_config[\"vmhint\"] The UUID of the VM that this VDI supports. This is set when VDIs are created through the user interface, to improve performance for certain storage backends.","title":"VDI"},{"location":"xc-api-extensions/#vbd","text":"Key Semantics VBD.other_config[\"owner\"] If set, then this disk may be deleted when the VM is uninstalled. VBD.other_config[\"class\"] Set to an integer, corresponding to the Best Effort setting of ionice .","title":"VBD"},{"location":"xc-api-extensions/#network","text":"Key Semantics network.other_config[\"automatic\"] The New VM wizard will create a VIF connected to this network by default, if this key has any value other than false . network.other_config[\"import_task\"] Gets the import task that created this network.","title":"Network"},{"location":"xc-api-extensions/#vm_guest_metrics","text":"Key Semantics PV_drivers_version[\"major\"] Gets the major version of the VM's PV drivers' version. PV_drivers_version[\"minor\"] Gets the minor version of the VM's PV drivers' version. PV_drivers_version[\"micro\"] Gets the micro (build number) of the VM's PV drivers' version.","title":"VM_guest_metrics"},{"location":"xc-api-extensions/#task","text":"Key Semantics task.other_config[\"object_creation\"] == \"complete\" For the task associated with a VM import, this flag will be set when all the objects (VMs, networks) have been created. This is useful in the import VM wizard for us to then go and re-map all the networks that need it.","title":"Task"},{"location":"xs-api-extensions/","text":"Citrix Hypervisor Management API extensions The Management API is a general and comprehensive interface to managing the life-cycles of virtual machines, and offers a lot of flexibility in the way that Management API providers may implement specific functionality (for example, storage provisioning, or console handling). Citrix Hypervisor has several extensions which provide useful functionality used in our own XenCenter interface. The workings of these mechanisms are described in this chapter. Extensions to the Management API are often provided by specifying other-config map keys to various objects. The use of this parameter indicates that the functionality is supported for that particular release of Citrix Hypervisor, but not as a long-term feature. We are constantly evaluating promoting functionality into the API, but this requires the nature of the interface to be well-understood. Developer feedback as to how you are using some of these extensions is always welcome to help us make these decisions. VM console forwarding Most Management API graphical interfaces will want to gain access to the VM consoles, in order to render them to the user as if they were physical machines. There are several types of consoles available, depending on the type of guest or if the physical host console is being accessed: Console access Operating System Text Graphical Optimized graphical Windows No VNC, using an API call RDP, directly from guest Linux Yes, through VNC and an API call No VNC, directly from guest Physical Host Yes, through VNC and an API call No No Hardware-assisted VMs, such as Windows, directly provide a graphical console over VNC. There is no text-based console, and guest networking is not necessary to use the graphical console. Once guest networking has been established, it is more efficient to setup Remote Desktop Access and use an RDP client to connect directly (this must be done outside of the XenAPI). Paravirtual VMs, such as Linux guests, provide a native text console directly. Citrix Hypervisor provides a utility (called vncterm ) to convert this text-based console into a graphical VNC representation. Guest networking is not necessary for this console to function. As with Windows above, Linux distributions often configure VNC within the guest, and directly connect to it over a guest network interface. The physical host console is only available as a vt100 console, which is exposed through the XenAPI as a VNC console by using vncterm in the control domain. RFB (Remote Framebuffer) is the protocol which underlies VNC, specified in The RFB Protocol . Third-party developers are expected to provide their own VNC viewers, and many freely available implementations can be adapted for this purpose. RFB 3.3 is the minimum version which viewers must support. Retrieving VNC consoles using the API VNC consoles are retrieved using a special URL passed through to the host agent. The sequence of API calls is as follows: Client to Master/443: RPC: Session.login_with_password() . Master/443 to Client: Returns a session reference to be used with subsequent calls. Client to Master/443: RPC: VM.get_by_name_label() . Master/443 to Client: Returns a reference to a particular VM (or the \"control domain\" if you want to retrieve the physical host console). Client to Master/443: RPC: VM.get_consoles() . Master/443 to Client: Returns a list of console objects associated with the VM. Client to Master/443: RPC: VM.get_location() . Returns a URI describing where the requested console is located. The URIs are of the form: https://192.168.0.1/console?ref=OpaqueRef:c038533a-af99-a0ff-9095-c1159f2dc6a0 or https://192.168.0.1/console?uuid=026e34fe-f0f2-20ee-5344-46d1aa922d5b Client to 192.168.0.1: HTTP CONNECT \"/console?ref=(...)\". You will also need to pass in \"session_id= \" as a cookie. The final HTTP CONNECT is slightly non-standard since the HTTP/1.1 RFC specifies that it should only be a host and a port, rather than a URL. Once the HTTP connect is complete, the connection can subsequently directly be used as a VNC server without any further HTTP protocol action. This scheme requires direct access from the client to the control domain's IP, and will not work correctly if there are Network Address Translation (NAT) devices blocking such connectivity. You can use the CLI to retrieve the console URI from the client and perform a connectivity check. Retrieve the VM UUID by running: xe vm-list params=uuid --minimal name-label=name Retrieve the console information: xe console-list vm-uuid=uuid uuid ( RO): 714f388b-31ed-67cb-617b-0276e35155ef vm-uuid ( RO): 8acb7723-a5f0-5fc5-cd53-9f1e3a7d3069 vm-name-label ( RO): etch protocol ( RO): RFB location ( RO): https://192.168.0.1/console?ref=(...) Use command-line utilities like ping to test connectivity to the IP address provided in the location field. Disabling VNC forwarding for Linux VM When creating and destroying Linux VMs, the host agent automatically manages the vncterm processes which convert the text console into VNC. Advanced users who wish to directly access the text console can disable VNC forwarding for that VM. The text console can then only be accessed directly from the control domain directly, and graphical interfaces such as XenCenter will not be able to render a console for that VM. Before starting the guest, set the following parameter on the VM record: xe vm-param-set uuid=uuid other-config:disable_pv_vnc=1 Start the VM. Use the CLI to retrieve the underlying domain ID of the VM with: xe vm-list params=dom-id uuid=uuid --minimal On the host console, connect to the text console directly by: /usr/lib/xen/bin/xenconsole domain_id This configuration is an advanced procedure, and we do not recommend that the text console is directly used for heavy I/O operations. Instead, connect to the guest over SSH or some other network-based connection mechanism. Paravirtual Linux installation The installation of paravirtual Linux guests is complicated by the fact that a Xen-aware kernel must be booted, rather than simply installing the guest using hardware-assistance. This does have the benefit of providing near-native installation speed due to the lack of emulation overhead. Citrix Hypervisor supports the installation of several different Linux distributions, and abstracts this process as much as possible. To this end, a special bootloader known as eliloader is present in the control domain which reads various other-config keys in the VM record at start time and performs distribution-specific installation behavior. install-repository - Required. Path to a repository; 'http', 'https', 'ftp', or 'nfs'. Should be specified as would be used by the target installer, but not including prefixes, for example, method=. install-vnc - Default: false. Use VNC where available during the installation. install-vncpasswd - Default: empty. The VNC password to use, when providing one is possible using the command-line of the target distribution. install-round - Default: 1. The current bootloader round. Not to be edited by the user. Adding xenstore entries to VMs Developers may wish to install guest agents into VMs which take special action based on the type of the VM. In order to communicate this information into the guest, a special Xenstore name-space known as vm-data is available which is populated at VM creation time. It is populated from the xenstore-data map in the VM record. Set the xenstore-data parameter in the VM record: xe vm-param-set uuid=vm_uuid xenstore-data:vm-data/foo=bar Start the VM. If it is a Linux-based VM, install the Citrix VM Tools and use the xenstore-read to verify that the node exists in xenstore. Note Only prefixes beginning with vm-data are permitted, and anything not in this name-space will be silently ignored when starting the VM. Security enhancements The control domain in Citrix Hypervisor has various security enhancements in order to harden it against attack from malicious guests. Developers should never notice any loss of correct functionality as a result of these changes, but they are documented here as variations of behavior from other distributions. The socket interface, xenstored , access using libxenstore . Interfaces are restricted by xs_restrict() . The device /dev/xen/evtchn , which is accessed by calling xs_evtchn_open() in libxenctrl . A handle can be restricted using xs_evtchn_restrict() . The device /proc/xen/privcmd , accessed through xs_interface_open() in libxenctrl . A handle is restricted using xc_interface_restrict() . Some privileged commands are naturally hard to restrict (for example, the ability to make arbitrary hypercalls), and these are simply prohibited on restricted handles. A restricted handle cannot later be granted more privilege, and so the interface must be closed and re-opened. Security is only gained if the process cannot subsequently open more handles. The control domain privileged user-space interfaces can now be restricted to only work for certain domains. There are three interfaces affected by this change: The qemu device emulation processes and vncterm terminal emulation processes run as a non-root user ID and are restricted into an empty directory. They uses the restriction API above to drop privileges where possible. Access to xenstore is rate-limited to prevent malicious guests from causing a denial of service on the control domain. This is implemented as a token bucket with a restricted fill-rate, where most operations take one token and opening a transaction takes 20. The limits are set high enough that they should never be hit when running even a large number of concurrent guests under loaded operation. The VNC guest consoles are bound only to the localhost interface, so that they are not exposed externally even if the control domain packet filter is disabled by user intervention. Advanced settings for network interfaces Virtual and physical network interfaces have some advanced settings that can be configured using the other-config map parameter. There is a set of custom ethtool settings and some miscellaneous settings. ethtool settings Developers might wish to configure custom ethtool settings for physical and virtual network interfaces. This is accomplished with ethtool-<option> keys in the other-config map parameter. Key Description Valid settings ethtool-rx Specify if RX checksumming is enabled on or true to enable the setting, off or false to disable it ethtool-tx Specify if TX checksumming is enabled on or true to enable the setting, off or false to disable it ethtool-sg Specify if scatter-gather is enabled on or true to enable the setting, off or false to disable it ethtool-tso Specify if tcp segmentation offload is enabled on or true to enable the setting, off or false to disable it ethtool-ufo Specify if UDP fragmentation offload is enabled on or true to enable the setting, off or false to disable it ethtool-gso Specify if generic segmentation offload is enabled on or true to enable the setting, off or false to disable it ethtool-autoneg Specify if autonegotiation is enabled on or true to enable the setting, off or false to disable it ethtool-speed Set the device speed in Mb/s 10, 100, or 1000 ethtool-duplex Set full or half duplex mode half or full For example, to enable TX checksumming on a virtual NIC using the xe CLI: xe vif-param-set uuid=<VIF UUID> other-config:ethtool-tx=\"on\" or: xe vif-param-set uuid=<VIF UUID> other-config:ethtool-tx=\"true\" To set the duplex setting on a physical NIC to half duplex using the xe CLI: xe vif-param-set uuid=<VIF UUID> other-config:ethtool-duplex=\"half\" Miscellaneous settings You can also set a promiscuous mode on a VIF or PIF by setting the promiscuous key to on . For example, to enable promiscuous mode on a physical NIC using the xe CLI: xe pif-param-set uuid=<PIF UUID> other-config:promiscuous=\"on\" or: xe pif-param-set uuid=<PIF UUID> other-config:promiscuous=\"true\" The VIF and PIF objects have a MTU parameter that is read-only and provide the current setting of the maximum transmission unit for the interface. You can override the default maximum transmission unit of a physical or virtual NIC with the mtu key in the other-config map parameter. For example, to reset the MTU on a virtual NIC to use jumbo frames using the xe CLI: xe vif-param-set uuid=<VIF UUID> other-config:mtu=9000 Note that changing the MTU of underlying interfaces is an advanced and experimental feature, and may lead to unexpected side-effects if you have varying MTUs across NICs in a single resource pool. Internationalization for SR names The SRs created at install time now have an other_config key indicating how their names may be internationalized. other_config[\"i18n-key\"] may be one of local-hotplug-cd local-hotplug-disk local-storage Citrix Hypervisor-tools Additionally, other_config[\"i18n-original-value-<field name>\"] gives the value of that field when the SR was created. If XenCenter sees a record where SR.name_label equals other_config[\"i18n-original-value-name_label\"] (that is, the record has not changed since it was created during Citrix Hypervisor installation), then internationalization will be applied. In other words, XenCenter will disregard the current contents of that field, and instead use a value appropriate to the user's own language. If you change SR.name_label for your own purpose, then it no longer is the same as other_config[\"i18n-original-value-name_label\"] . Therefore, XenCenter does not apply internationalization, and instead preserves your given name. Hiding objects from XenCenter Networks, PIFs, and VMs can be hidden from XenCenter by adding the key HideFromXenCenter=true to the other_config parameter for the object. This capability is intended for ISVs who know what they are doing, not general use by everyday users. For example, you might want to hide certain VMs because they are cloned VMs that shouldn't be used directly by general users in your environment. In XenCenter, hidden Networks, PIFs, and VMs can be made visible, using the View menu.","title":"Citrix Hypervisor Management API Extensions"},{"location":"xs-api-extensions/#citrix-hypervisor-management-api-extensions","text":"The Management API is a general and comprehensive interface to managing the life-cycles of virtual machines, and offers a lot of flexibility in the way that Management API providers may implement specific functionality (for example, storage provisioning, or console handling). Citrix Hypervisor has several extensions which provide useful functionality used in our own XenCenter interface. The workings of these mechanisms are described in this chapter. Extensions to the Management API are often provided by specifying other-config map keys to various objects. The use of this parameter indicates that the functionality is supported for that particular release of Citrix Hypervisor, but not as a long-term feature. We are constantly evaluating promoting functionality into the API, but this requires the nature of the interface to be well-understood. Developer feedback as to how you are using some of these extensions is always welcome to help us make these decisions.","title":"Citrix Hypervisor Management API extensions"},{"location":"xs-api-extensions/#vm-console-forwarding","text":"Most Management API graphical interfaces will want to gain access to the VM consoles, in order to render them to the user as if they were physical machines. There are several types of consoles available, depending on the type of guest or if the physical host console is being accessed:","title":"VM console forwarding"},{"location":"xs-api-extensions/#console-access","text":"Operating System Text Graphical Optimized graphical Windows No VNC, using an API call RDP, directly from guest Linux Yes, through VNC and an API call No VNC, directly from guest Physical Host Yes, through VNC and an API call No No Hardware-assisted VMs, such as Windows, directly provide a graphical console over VNC. There is no text-based console, and guest networking is not necessary to use the graphical console. Once guest networking has been established, it is more efficient to setup Remote Desktop Access and use an RDP client to connect directly (this must be done outside of the XenAPI). Paravirtual VMs, such as Linux guests, provide a native text console directly. Citrix Hypervisor provides a utility (called vncterm ) to convert this text-based console into a graphical VNC representation. Guest networking is not necessary for this console to function. As with Windows above, Linux distributions often configure VNC within the guest, and directly connect to it over a guest network interface. The physical host console is only available as a vt100 console, which is exposed through the XenAPI as a VNC console by using vncterm in the control domain. RFB (Remote Framebuffer) is the protocol which underlies VNC, specified in The RFB Protocol . Third-party developers are expected to provide their own VNC viewers, and many freely available implementations can be adapted for this purpose. RFB 3.3 is the minimum version which viewers must support.","title":"Console access"},{"location":"xs-api-extensions/#retrieving-vnc-consoles-using-the-api","text":"VNC consoles are retrieved using a special URL passed through to the host agent. The sequence of API calls is as follows: Client to Master/443: RPC: Session.login_with_password() . Master/443 to Client: Returns a session reference to be used with subsequent calls. Client to Master/443: RPC: VM.get_by_name_label() . Master/443 to Client: Returns a reference to a particular VM (or the \"control domain\" if you want to retrieve the physical host console). Client to Master/443: RPC: VM.get_consoles() . Master/443 to Client: Returns a list of console objects associated with the VM. Client to Master/443: RPC: VM.get_location() . Returns a URI describing where the requested console is located. The URIs are of the form: https://192.168.0.1/console?ref=OpaqueRef:c038533a-af99-a0ff-9095-c1159f2dc6a0 or https://192.168.0.1/console?uuid=026e34fe-f0f2-20ee-5344-46d1aa922d5b Client to 192.168.0.1: HTTP CONNECT \"/console?ref=(...)\". You will also need to pass in \"session_id= \" as a cookie. The final HTTP CONNECT is slightly non-standard since the HTTP/1.1 RFC specifies that it should only be a host and a port, rather than a URL. Once the HTTP connect is complete, the connection can subsequently directly be used as a VNC server without any further HTTP protocol action. This scheme requires direct access from the client to the control domain's IP, and will not work correctly if there are Network Address Translation (NAT) devices blocking such connectivity. You can use the CLI to retrieve the console URI from the client and perform a connectivity check. Retrieve the VM UUID by running: xe vm-list params=uuid --minimal name-label=name Retrieve the console information: xe console-list vm-uuid=uuid uuid ( RO): 714f388b-31ed-67cb-617b-0276e35155ef vm-uuid ( RO): 8acb7723-a5f0-5fc5-cd53-9f1e3a7d3069 vm-name-label ( RO): etch protocol ( RO): RFB location ( RO): https://192.168.0.1/console?ref=(...) Use command-line utilities like ping to test connectivity to the IP address provided in the location field.","title":"Retrieving VNC consoles using the API"},{"location":"xs-api-extensions/#disabling-vnc-forwarding-for-linux-vm","text":"When creating and destroying Linux VMs, the host agent automatically manages the vncterm processes which convert the text console into VNC. Advanced users who wish to directly access the text console can disable VNC forwarding for that VM. The text console can then only be accessed directly from the control domain directly, and graphical interfaces such as XenCenter will not be able to render a console for that VM. Before starting the guest, set the following parameter on the VM record: xe vm-param-set uuid=uuid other-config:disable_pv_vnc=1 Start the VM. Use the CLI to retrieve the underlying domain ID of the VM with: xe vm-list params=dom-id uuid=uuid --minimal On the host console, connect to the text console directly by: /usr/lib/xen/bin/xenconsole domain_id This configuration is an advanced procedure, and we do not recommend that the text console is directly used for heavy I/O operations. Instead, connect to the guest over SSH or some other network-based connection mechanism.","title":"Disabling VNC forwarding for Linux VM"},{"location":"xs-api-extensions/#paravirtual-linux-installation","text":"The installation of paravirtual Linux guests is complicated by the fact that a Xen-aware kernel must be booted, rather than simply installing the guest using hardware-assistance. This does have the benefit of providing near-native installation speed due to the lack of emulation overhead. Citrix Hypervisor supports the installation of several different Linux distributions, and abstracts this process as much as possible. To this end, a special bootloader known as eliloader is present in the control domain which reads various other-config keys in the VM record at start time and performs distribution-specific installation behavior. install-repository - Required. Path to a repository; 'http', 'https', 'ftp', or 'nfs'. Should be specified as would be used by the target installer, but not including prefixes, for example, method=. install-vnc - Default: false. Use VNC where available during the installation. install-vncpasswd - Default: empty. The VNC password to use, when providing one is possible using the command-line of the target distribution. install-round - Default: 1. The current bootloader round. Not to be edited by the user.","title":"Paravirtual Linux installation"},{"location":"xs-api-extensions/#adding-xenstore-entries-to-vms","text":"Developers may wish to install guest agents into VMs which take special action based on the type of the VM. In order to communicate this information into the guest, a special Xenstore name-space known as vm-data is available which is populated at VM creation time. It is populated from the xenstore-data map in the VM record. Set the xenstore-data parameter in the VM record: xe vm-param-set uuid=vm_uuid xenstore-data:vm-data/foo=bar Start the VM. If it is a Linux-based VM, install the Citrix VM Tools and use the xenstore-read to verify that the node exists in xenstore. Note Only prefixes beginning with vm-data are permitted, and anything not in this name-space will be silently ignored when starting the VM.","title":"Adding xenstore entries to VMs"},{"location":"xs-api-extensions/#security-enhancements","text":"The control domain in Citrix Hypervisor has various security enhancements in order to harden it against attack from malicious guests. Developers should never notice any loss of correct functionality as a result of these changes, but they are documented here as variations of behavior from other distributions. The socket interface, xenstored , access using libxenstore . Interfaces are restricted by xs_restrict() . The device /dev/xen/evtchn , which is accessed by calling xs_evtchn_open() in libxenctrl . A handle can be restricted using xs_evtchn_restrict() . The device /proc/xen/privcmd , accessed through xs_interface_open() in libxenctrl . A handle is restricted using xc_interface_restrict() . Some privileged commands are naturally hard to restrict (for example, the ability to make arbitrary hypercalls), and these are simply prohibited on restricted handles. A restricted handle cannot later be granted more privilege, and so the interface must be closed and re-opened. Security is only gained if the process cannot subsequently open more handles. The control domain privileged user-space interfaces can now be restricted to only work for certain domains. There are three interfaces affected by this change: The qemu device emulation processes and vncterm terminal emulation processes run as a non-root user ID and are restricted into an empty directory. They uses the restriction API above to drop privileges where possible. Access to xenstore is rate-limited to prevent malicious guests from causing a denial of service on the control domain. This is implemented as a token bucket with a restricted fill-rate, where most operations take one token and opening a transaction takes 20. The limits are set high enough that they should never be hit when running even a large number of concurrent guests under loaded operation. The VNC guest consoles are bound only to the localhost interface, so that they are not exposed externally even if the control domain packet filter is disabled by user intervention.","title":"Security enhancements"},{"location":"xs-api-extensions/#advanced-settings-for-network-interfaces","text":"Virtual and physical network interfaces have some advanced settings that can be configured using the other-config map parameter. There is a set of custom ethtool settings and some miscellaneous settings.","title":"Advanced settings for network interfaces"},{"location":"xs-api-extensions/#ethtool-settings","text":"Developers might wish to configure custom ethtool settings for physical and virtual network interfaces. This is accomplished with ethtool-<option> keys in the other-config map parameter. Key Description Valid settings ethtool-rx Specify if RX checksumming is enabled on or true to enable the setting, off or false to disable it ethtool-tx Specify if TX checksumming is enabled on or true to enable the setting, off or false to disable it ethtool-sg Specify if scatter-gather is enabled on or true to enable the setting, off or false to disable it ethtool-tso Specify if tcp segmentation offload is enabled on or true to enable the setting, off or false to disable it ethtool-ufo Specify if UDP fragmentation offload is enabled on or true to enable the setting, off or false to disable it ethtool-gso Specify if generic segmentation offload is enabled on or true to enable the setting, off or false to disable it ethtool-autoneg Specify if autonegotiation is enabled on or true to enable the setting, off or false to disable it ethtool-speed Set the device speed in Mb/s 10, 100, or 1000 ethtool-duplex Set full or half duplex mode half or full For example, to enable TX checksumming on a virtual NIC using the xe CLI: xe vif-param-set uuid=<VIF UUID> other-config:ethtool-tx=\"on\" or: xe vif-param-set uuid=<VIF UUID> other-config:ethtool-tx=\"true\" To set the duplex setting on a physical NIC to half duplex using the xe CLI: xe vif-param-set uuid=<VIF UUID> other-config:ethtool-duplex=\"half\"","title":"ethtool settings"},{"location":"xs-api-extensions/#miscellaneous-settings","text":"You can also set a promiscuous mode on a VIF or PIF by setting the promiscuous key to on . For example, to enable promiscuous mode on a physical NIC using the xe CLI: xe pif-param-set uuid=<PIF UUID> other-config:promiscuous=\"on\" or: xe pif-param-set uuid=<PIF UUID> other-config:promiscuous=\"true\" The VIF and PIF objects have a MTU parameter that is read-only and provide the current setting of the maximum transmission unit for the interface. You can override the default maximum transmission unit of a physical or virtual NIC with the mtu key in the other-config map parameter. For example, to reset the MTU on a virtual NIC to use jumbo frames using the xe CLI: xe vif-param-set uuid=<VIF UUID> other-config:mtu=9000 Note that changing the MTU of underlying interfaces is an advanced and experimental feature, and may lead to unexpected side-effects if you have varying MTUs across NICs in a single resource pool.","title":"Miscellaneous settings"},{"location":"xs-api-extensions/#internationalization-for-sr-names","text":"The SRs created at install time now have an other_config key indicating how their names may be internationalized. other_config[\"i18n-key\"] may be one of local-hotplug-cd local-hotplug-disk local-storage Citrix Hypervisor-tools Additionally, other_config[\"i18n-original-value-<field name>\"] gives the value of that field when the SR was created. If XenCenter sees a record where SR.name_label equals other_config[\"i18n-original-value-name_label\"] (that is, the record has not changed since it was created during Citrix Hypervisor installation), then internationalization will be applied. In other words, XenCenter will disregard the current contents of that field, and instead use a value appropriate to the user's own language. If you change SR.name_label for your own purpose, then it no longer is the same as other_config[\"i18n-original-value-name_label\"] . Therefore, XenCenter does not apply internationalization, and instead preserves your given name.","title":"Internationalization for SR names"},{"location":"xs-api-extensions/#hiding-objects-from-xencenter","text":"Networks, PIFs, and VMs can be hidden from XenCenter by adding the key HideFromXenCenter=true to the other_config parameter for the object. This capability is intended for ISVs who know what they are doing, not general use by everyday users. For example, you might want to hide certain VMs because they are cloned VMs that shouldn't be used directly by general users in your environment. In XenCenter, hidden Networks, PIFs, and VMs can be made visible, using the View menu.","title":"Hiding objects from XenCenter"}]}